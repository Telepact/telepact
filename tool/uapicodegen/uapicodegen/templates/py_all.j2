import keyword
from typing import Callable, TypeVar
from dataclasses import dataclass
from typing import cast, ForwardRef


T = TypeVar('T')
U = TypeVar('U')

def util_let(value: T, f: Callable[[T], U]) -> U:
    return f(value)

class Undefined:
    pass


{%- macro to_py_type(t) %}
    {%- set typ = t | replace('?', '') %}
    {%- if typ == 'array' %}
        {{- 'list' -}}
    {%- elif typ == 'object' %}
        {{- 'dict' -}}
    {%- elif typ == 'boolean' %}
        {{- 'bool' -}}
    {%- elif typ == 'integer' %}
        {{- 'int' -}}
    {%- elif typ == 'number' %}
        {{- 'float' -}}
    {%- elif typ == 'string' %}
        {{- 'str' -}}
    {%- elif typ == 'any' %}
        {{- 'object' -}}
    {%- elif typ.startswith('fn.') -%}
        {{ typ | regex_replace('^.*\\.', '') -}}.Input
    {%- else -%}
        {{ typ | regex_replace('^.*\\.', '') -}}
    {%- endif %}
{%- endmacro -%}

{%- macro marshall_py_type(t, depth) -%}
    {%- set nullable = '?' in t[0] %}
    {%- set typ = t[0] | replace('?', '') -%}
    {%- if typ == 'array' -%}
        util_let(cast(list[object], {{ caller() }}), lambda d{{depth}}: {% if nullable %}None if d{{depth}} is None else {% endif %}[{% call marshall_py_type(t[1:][0], depth + 1) %}e{{ depth }}{% endcall %} for e{{depth}} in d{{depth}}])
    {%- elif typ == 'object' -%}
        util_let(cast(dict[str, object], {{ caller() }}), lambda d{{depth}}: {% if nullable %}None if d{{depth}} is None else {% endif %}{ k{{depth}}: {%- call marshall_py_type(t[1:][0], depth + 1) %}v{{ depth }}{% endcall %} for k{{depth}}, v{{depth}} in d{{depth}}.items() })
    {%- elif typ == 'boolean' -%}
        cast(bool, {{ caller() }})
    {%- elif typ == 'integer' -%}
        cast(int, {{ caller()}})
    {%- elif typ == 'number' -%}
        cast(float, {{ caller() }})
    {%- elif typ == 'string' -%}
        cast(str, {{ caller() }})
    {%- elif typ == 'any' -%}
        cast(str, {{ caller() }})
    {%- elif typ.startswith('struct') or typ.startswith('fn') -%}
        util_let({{ caller() }}, lambda d{{ depth }}: {% if nullable %}None if d{{depth}} is None else {% endif %}{{ to_py_type(typ) }}.from_pseudo_json(cast(dict[str, object], d{{ depth }})))
    {%- elif typ.startswith('union') -%}
        util_let({{ caller() }}, lambda d{{ depth }}: {% if nullable %}None if d{{depth}} is None else {% endif %}{{ to_py_type(typ) }}.from_pseudo_json(cast(dict[str, object], d{{depth}})))
    {%- else -%}
        {{- ('Unknown type: ' + typ) | raise_error -}}
    {%- endif -%}
{%- endmacro -%}

{%- macro unmarshall_py_type(t, depth) -%}
    {%- set typ = t[0] | replace('?', '') -%}
    {%- if typ == 'array' -%}
        util_let({{ caller() }}, lambda d{{depth}}: None if d{{depth}} is None else [{% call unmarshall_py_type(t[1:][0], depth + 1 )%}e{{ depth }}{% endcall %} for e{{depth}} in d{{depth}}])
    {%- elif typ == 'object' -%}
        util_let({{ caller() }}, lambda d{{depth}}: None if d{{depth}} is None else { k{{depth}}: {%- call unmarshall_py_type(t[1:][0], depth + 1) %}v{{ depth }}{% endcall %} for k{{depth}}, v{{depth}} in d{{depth}}.items()})
    {%- elif typ == 'boolean' -%}
        {{ caller() }}
    {%- elif typ == 'integer' -%}
        {{ caller() }}
    {%- elif typ == 'number' -%}
        {{ caller() }}
    {%- elif typ == 'string' -%}
        {{ caller() }}
    {%- elif typ == 'any' -%}
        {{ caller() }}
    {%- else -%}
        util_let({{ caller() }}, d{{depth}} -> d{{depth}} == null ? null : d{{depth}}.to_pseudo_json())
    {%- endif -%}
{%- endmacro -%}

{%- macro marshall_py_type_maybe_opt(field_name, field_type) -%}
    {% call marshall_py_type(field_type, 0) %}map_.get("{{ field_name }}", Undefined()){% endcall %}
{%- endmacro -%}

{%- macro setter_maybe_opt(field_name) -%}
    {{ caller() }}
{%- endmacro -%}

{%- macro docstring(data) -%}
    {%- if '///' in data %}
'''
        {%- set doc = data['///'] -%}
        {%- if doc is iterable and doc is not string -%}
            {%- for line in doc %}
 {{ line }}
            {%- endfor %}
        {%- else %}
 {{ doc }}
        {%- endif %}
 '''
    {%- endif %}
{%- endmacro -%}

{%- macro sanitize_field_name(field_name) -%}
    {%- set sanitized_name =  field_name | replace('!', '') -%}
    {%- set py_keywords = ['False', 'None', 'True', 'and', 'as', 'assert', 'async', 'await', 'break', 'class', 'continue', 'def', 'del', 'elif', 'else', 'except', 'finally', 'for', 'from', 'global', 'if', 'import', 'in', 'is', 'lambda', 'nonlocal', 'not', 'or', 'pass', 'raise', 'return', 'try', 'while', 'with', 'yield'] %}
    {%- if sanitized_name in py_keywords -%}
        {{- sanitized_name + '_' -}}
    {%- else -%}
        {{- sanitized_name -}}
    {%- endif -%}
{%- endmacro -%}

{%- macro translate(type, optional) -%}
    {{- to_py_type(type[0]) -}}
    {%- set typ = type[0] | replace('?', '') -%}
    {%- if type | length > 1 -%}
        {{- '[' -}}
        {%- if typ == 'object' %}
            {{- 'str, ' -}}
        {%- endif %}
        {%- for t in type[1:] -%}
            {{- translate(t) -}}{{ ", " if not loop.last -}}
        {%- endfor -%}
        {{- ']' -}}
    {%- endif -%}
    {%- if optional %} | Undefined{%- endif %}
{%- endmacro -%}

{%- macro struct(data, schema_key, alt_name, modifier, implements, unionCase, fn, typ_pref) %}
    {%- set fields = data[schema_key] %}
    {%- set py_name = alt_name if alt_name else schema_key | regex_replace('^.*\\.', '') %}
    {%- set type_str = type_pref + py_name if type_pref else py_name %}
    {{ docstring(data) }}
@dataclass
class {{ py_name }}{% if implements %}({{ implements }}){% endif %}:
    {%- for field_name, field_type in fields.items() %}
    {{ sanitize_field_name(field_name) }}: '{{ translate(field_type, '!' in field_name) }}'{% if '!' in field_name %} = Undefined(){% endif %} # type: ignore
    {%- endfor %}

    @classmethod
    def from_pseudo_json(cls, map_{% if fn %}init{% endif %}: dict[str, object]) -> '{{ type_str }}':
        {%- if fn %}
        map_ = map_init["{{ unionCase }}"]
        {%- endif %}
        return cls(
            {%- for field_name, field_type in fields.items() %}
            {{ sanitize_field_name(field_name) }} = {{ marshall_py_type_maybe_opt(field_name, field_type) }},
            {%- endfor %}
        )

    def to_pseudo_json(self) -> dict[str, object]:
        fields: dict[str, object] = {}
        {%- for field_name, field_type in fields.items() %}
            {%- if '!' in field_name %}
        if not isinstance(self.{{ sanitize_field_name(field_name) }}, Undefined):
            fields["{{ field_name }}"] = self.{{ sanitize_field_name(field_name) }}
            {%- else %}
        fields["{{ field_name }}"] = self.{{ sanitize_field_name(field_name) }}
            {%- endif %}
        {%- endfor %}
        {%- if unionCase %}
        return {
            "{{ unionCase }}": fields
        }
        {%- else %}
        return fields
        {%- endif %}
{%- endmacro %}

{%- macro union(data, schema_key, fn) %}
    {%- set cases = data[schema_key] %}
    {%- if schema_key == '->' %}
        {%- set schema_key = 'Output' %}
    {%- endif %}
    {%- set py_name = schema_key | regex_replace('^.*\\.', '') %}
    {%- set super_class = fn + '_output_type_' if fn else py_name + '_type_' %}
    {%- set typ_pref = fn + '.Output.' if fn else py_name + '.'%}
    {{ docstring(data) }}
class {{ py_name }}:
    {{ struct({'NoMatch_': {} }, 'NoMatch_', None, 'final ', super_class, 'NoMatch_', fn, typ_pref) | indent }}

    {%- for case_entry in cases %}
        {% set case_key = case_entry | find_case_key %}
        {{ struct(case_entry, case_key, None, 'final ', super_class, case_key, fn, typ_pref) | indent }}
    {%- endfor %}

    {%- set final_fn = fn + '.' if fn else '' %}

    @staticmethod
    def from_pseudo_json(map_: dict[str, object]) -> {{ final_fn + py_name }}:
        entry = next(iter(map_.items()))
        case_name = entry[0]
        payload = entry[1]
        if case_name == "NoMatch_":
            return {{ final_fn + py_name }}.NoMatch_(payload)
        {%- for case_entry in cases %}
            {% set case_key = case_entry | find_case_key %}
        elif case_name == "{{ case_key }}":
            return {{ final_fn + py_name }}.{{ case_key }}(payload)
        {%- endfor %}
        else:
            return {{ final_fn + py_name }}.NoMatch_(payload)
    
    def to_pseudo_json(self):
        pass

{%- endmacro %}

{%- macro function(data, schema_key) %}
    {%- set fields = data[schema_key] %}
    {%- set py_name = schema_key | regex_replace('^.*\\.', '') %}
class {{ py_name }}:

    {{ struct(data, schema_key, 'Input', 'static ', None, schema_key, py_name, py_name + '.') | indent }}

    {% do data.pop('///', None) %}

    {{ union (data, '->', py_name) | indent }}
{%- endmacro %}

{%- for schema_entry in input %}
    {%- set schema_key = schema_entry | find_schema_key %}
    {%- set py_name = schema_key | regex_replace('^.*\\.', '') %}
    {%- if schema_key.startswith('union') %}
{{- py_name }}_type_ = ForwardRef('{{ py_name }}')
    {%- elif schema_key.startswith('fn') %}
{{- py_name }}_output_type_ = ForwardRef('{{ py_name }}.Output')
    {%- endif %}
{% endfor %}

{%- for schema_entry in input %}
    {%- set schema_key = schema_entry | find_schema_key %}

    {% set py_name = schema_key | regex_replace('^.*\\.', '') %}
    {%- if schema_key.startswith('struct') %}
        {{- struct(schema_entry, schema_key, None, "", None, None, None) }}
    {%- elif schema_key.startswith('union') %}
        {{- union(schema_entry, schema_key, None) }}
    {%- elif schema_key.startswith('fn') %}
        {{ function(schema_entry, schema_key) }}
    {%- endif %}
{% endfor %}


from uapi import Message, Client

class ClientInterface_:

    client: Client

    def __init__(self, client: Client):
        self.client = client

    {% for fn in functions %}
    {%- set function_name = fn | replace('fn.', '') %}
    def {{ function_name }}(self, headers: dict[str, object], input: {{ function_name }}.Input) -> {{ function_name }}.Output:
        message = self.client.request(Message(headers, input.to_pseudo_json()))
        return {{ function_name }}.Output.from_pseudo_json(message.body)
    {%- endfor %}


class ServerHandler_:

    {%- for fn in functions %}
    {%- set function_name = fn | replace('fn.', '') %}
    def {{function_name}}(self, headers: dict[str, object], input: {{ function_name }}.Input) -> {{ function_name }}.Output:
        raise NotImplementedError()
    {%- endfor %}

    def handler(self, message: Message) -> Message:
        function_name = next(iter(message.body.keys()))

        {%- for fn in functions %}
        {%- set function_name = fn | replace('fn.', '') %}
        {% if loop.first %}
        if function_name == "{{ fn }}":
            output = self.{{ function_name }}(message.header, {{ function_name }}.Input(message.body))
            return Message({}, output.to_pseudo_json())
        {% else %}
        elif function_name == "{{ fn }}":
            output = self.{{ function_name }}(message.header, {{ function_name }}.Input(message.body))
            return Message({}, output.to_pseudo_json())
        {% endif %}
        {%- endfor %}

        raise Exception("Unknown function: " + function_name)
