import keyword
from typing import Callable, TypeVar
from dataclasses import dataclass
from typing import cast, ForwardRef
from abc import ABC, abstractmethod


T = TypeVar('T')
U = TypeVar('U')

def util_let(value: T, f: Callable[[T], U]) -> U:
return f(value)

class Undefined:
pass


{%- macro to_py_type(t, append_nullable=True) %}
{%- set nullable = '?' in t[0] -%}
{%- set typ = t[0] | replace('?', '') -%}
{%- if typ == 'array' -%}
list[{{ to_py_type(t[1:][0]) }}]
{%- elif typ == 'object' -%}
dict[str, {{ to_py_type(t[1:][0]) }}]
{%- elif typ == 'boolean' -%}
bool
{%- elif typ == 'integer' -%}
int
{%- elif typ == 'number' -%}
float
{%- elif typ == 'string' -%}
str
{%- elif typ == 'any' -%}
object
{%- elif typ.startswith('fn.') -%}
{{ typ | regex_replace('^.*\\.', '') -}}__Input_
{%- else -%}
{{ typ | regex_replace('^.*\\.', '') -}}
{%- endif -%}
{%- if append_nullable and nullable %} | None{%- endif -%}
{%- endmacro -%}

{%- macro marshall_py_type(t, depth) -%}
{%- set nullable = '?' in t[0] %}
{%- set typ = t[0] | replace('?', '') -%}
{%- if typ == 'array' -%}
util_let(cast({{ to_py_type(t) }}, {{ caller() }}), lambda d{{depth}}: {% if nullable %}None if d{{depth}} is None else
{% endif %}[{% call marshall_py_type(t[1:][0], depth + 1) %}e{{ depth }}{% endcall %} for e{{depth}} in d{{depth}}])
{%- elif typ == 'object' -%}
util_let(cast({{ to_py_type(t) }}, {{ caller() }}), lambda d{{depth}}: {% if nullable %}None if d{{depth}} is None else
{% endif %}{ k{{depth}}: {%- call marshall_py_type(t[1:][0], depth + 1) %}v{{ depth }}{% endcall %} for k{{depth}},
v{{depth}} in d{{depth}}.items() })
{%- elif typ.startswith('struct') or typ.startswith('fn') -%}
util_let({{ caller() }}, lambda d{{ depth }}: {% if nullable %}None if d{{depth}} is None else {% endif %}{{
to_py_type(t, False) }}.from_pseudo_json(cast(dict[str, object], d{{ depth }})))
{%- elif typ.startswith('union') -%}
util_let({{ caller() }}, lambda d{{ depth }}: {% if nullable %}None if d{{depth}} is None else {% endif %}{{
to_py_type(t, False) }}.from_pseudo_json(cast(dict[str, object], d{{depth}})))
{%- else -%}
cast({{ to_py_type(t) }}, {{ caller() }})
{%- endif -%}
{%- endmacro -%}

{%- macro unmarshall_py_type(t, depth) -%}
{%- set typ = t[0] | replace('?', '') -%}
{%- if typ == 'array' -%}
util_let({{ caller() }}, lambda d{{depth}}: None if d{{depth}} is None else [{% call unmarshall_py_type(t[1:][0], depth
+ 1 )%}e{{ depth }}{% endcall %} for e{{depth}} in d{{depth}}])
{%- elif typ == 'object' -%}
util_let({{ caller() }}, lambda d{{depth}}: None if d{{depth}} is None else { k{{depth}}: {%- call
unmarshall_py_type(t[1:][0], depth + 1) %}v{{ depth }}{% endcall %} for k{{depth}}, v{{depth}} in d{{depth}}.items()})
{%- elif typ.startswith('struct') or typ.startswith('fn') or typ.startswith('union') -%}
util_let({{ caller() }}, lambda d{{depth}}: None if d{{depth}} is None else d{{depth}}.to_pseudo_json())
{%- else -%}
{{ caller() }}
{%- endif -%}
{%- endmacro -%}

{%- macro to_maybe_opt_py_type(type, field_name) -%}
{%- if '!' in field_name -%}
{{- to_py_type(type) }} | Undefined
{%- else %}
{{- to_py_type(type) }}
{%- endif %}
{%- endmacro -%}

{%- macro setter_maybe_opt(field_name) -%}
{{ caller() }}
{%- endmacro -%}

{%- macro docstring(doc) -%}
{%- if doc -%}
'''
{%- if doc is iterable and doc is not string -%}
{%- for line in doc %}
{{ line }}
{%- endfor %}
{%- else %}
{{ doc }}
{%- endif %}
'''
{%- endif %}
{%- endmacro -%}

{%- macro sanitize_field_name(field_name) -%}
{%- set sanitized_name = field_name | replace('!', '') -%}
{%- set py_keywords = ['bool', 'int', 'str', 'False', 'None', 'True', 'and', 'as', 'assert', 'async', 'await', 'break',
'class', 'continue', 'def', 'del', 'elif', 'else', 'except', 'finally', 'for', 'from', 'global', 'if', 'import', 'in',
'is', 'lambda', 'nonlocal', 'not', 'or', 'pass', 'raise', 'return', 'try', 'while', 'with', 'yield'] %}
{%- if sanitized_name in py_keywords -%}
{{- sanitized_name + '_' -}}
{%- else -%}
{{- sanitized_name -}}
{%- endif -%}
{%- endmacro -%}

{%- macro tag_type_display(type_display, tag_key) %}
{{- type_display + ('_' if type_display.endswith('_') else '__') + tag_key }}
{%- endmacro %}

{%- macro struct(type_display, doc, fields, implements, union_tag) %}
@dataclass
class {{ type_display }}{% if implements %}({{ implements }}){% endif %}:
{{ docstring(doc) | indent }}

{%- for field_name, field_type in fields.items() %}
{{ sanitize_field_name(field_name) }}: '{{ to_maybe_opt_py_type(field_type, field_name) }}'{% if '!' in field_name %} =
Undefined(){% endif %} # type: ignore
{%- endfor %}

@classmethod
def from_pseudo_json(cls, map_{% if union_tag %}init{% endif %}: dict[str, object]) -> '{{ type_display }}':
{%- if union_tag %}
map_ = cast(dict[str, object], map_init["{{ union_tag }}"])
{%- endif %}
return cls(
{%- for field_name, field_type in fields.items() %}
{{ sanitize_field_name(field_name) + ' ' -}}
= {% if '!' in field_name %}Undefined() if '{{- field_name }}' not in map_ else {% endif -%}
{%- call marshall_py_type(field_type, 0) %}map_["{{ field_name }}"]{% endcall %},
{%- endfor %}
)

def to_pseudo_json(self) -> dict[str, object]:
fields: dict[str, object] = {}
{%- for field_name, field_type in fields.items() %}
{%- if '!' in field_name %}
if not isinstance(self.{{ sanitize_field_name(field_name) }}, Undefined):
fields["{{ field_name }}"] = {% call unmarshall_py_type(field_type, 0) %}self.{{ sanitize_field_name(field_name) }}{%
endcall %}
{%- else %}
fields["{{ field_name }}"] = {% call unmarshall_py_type(field_type, 0) %}self.{{ sanitize_field_name(field_name) }}{%
endcall %}
{%- endif %}
{%- endfor %}
{%- if union_tag %}
return {
"{{ union_tag }}": fields
}
{%- else %}
return fields
{%- endif %}
{%- endmacro %}

{%- macro no_match_struct(type_display, implements) %}
@dataclass
class {{ type_display }}{% if implements %}({{ implements }}){% endif %}:
original: dict[str, object]

@classmethod
def from_pseudo_json(cls, map_: dict[str, object]) -> '{{ type_display }}':
return cls(
original=map_
)

def to_pseudo_json(self) -> dict[str, object]:
return self.original
{%- endmacro %}

{%- macro union(type_display, doc, tags) %}

class {{ type_display }}(ABC):
{{ docstring(doc) | indent }}

@staticmethod
def from_pseudo_json(map_: dict[str, object]) -> '{{ type_display }}':
entry = next(iter(map_.items()))
tag_name = entry[0]
payload = cast(dict[str, object], entry[1])
{%- for tag_entry in tags %}
{% set tag_key = tag_entry | find_tag_key %}
{% if loop.first%}if{% else %}elif{% endif %} tag_name == "{{ tag_key }}":
return cast({{ type_display }}, {{ tag_type_display(type_display, tag_key) }}.from_pseudo_json(map_))
{%- endfor %}
else:
return cast({{ type_display }}, {{ tag_type_display(type_display, 'NoMatch_') }}.from_pseudo_json(map_))

@abstractmethod
def to_pseudo_json(self) -> dict[str, object]:
raise NotImplementedError()

{{ no_match_struct(tag_type_display(type_display, 'NoMatch_'), type_display)}}

{%- for tag_entry in tags %}
{% set tag_key = tag_entry | find_tag_key %}
{% set tag_type_display_res = tag_type_display(type_display, tag_key) %}
{{ struct(tag_type_display_res, tag_entry['///'], tag_entry[tag_key], type_display, tag_key) }}
{%- endfor %}
{%- endmacro %}

{%- macro function(type_display, data, schema_key) %}

{{ struct(type_display + '__Input_', data['///'], data[schema_key], None, schema_key) }}

{{ union (type_display + '__Output_', data['///'], data['->'])}}
{%- endmacro %}

{%- for schema_entry in input %}
{%- set schema_key = schema_entry | find_schema_key %}

{% set py_name = schema_key | regex_replace('^.*\\.', '') %}
{%- if schema_key.startswith('struct') %}
{{- struct(py_name, schema_entry['///'], schema_entry[schema_key], None, None) }}
{%- elif schema_key.startswith('union') %}
{{- union(py_name, schema_entry['///'], schema_entry[schema_key]) }}
{%- elif schema_key.startswith('fn') %}
{{ function(py_name, schema_entry,schema_key) }}
{%- endif %}
{% endfor %}

import uapi.Message
import uapi.Client
from typing import Tuple

class ClientInterface_:

client: uapi.Client.Client

def __init__(self, client: uapi.Client.Client):
self.client = client

{% for fn in functions %}
{%- set function_name = fn | replace('fn.', '') %}
async def {{ function_name }}(self, headers: dict[str, object], input: {{ function_name }}__Input_) -> Tuple[dict[str,
object], {{ function_name }}__Output_]:
message = await self.client.request(uapi.Message.Message(headers, input.to_pseudo_json()))
return message.header, {{ function_name }}__Output_.from_pseudo_json(message.body)
{%- endfor %}


class ServerHandler_:

{%- for fn in functions %}
{%- set function_name = fn | replace('fn.', '') %}
async def {{function_name}}(self, headers: dict[str, object], input: {{ function_name }}__Input_) -> Tuple[dict[str,
object], {{ function_name }}__Output_]:
raise NotImplementedError()
{%- endfor %}

async def handler(self, message: uapi.Message.Message) -> uapi.Message.Message:
function_name = next(iter(message.body.keys()))

{%- for fn in functions %}
{%- set function_name = fn | replace('fn.', '') %}
{% if loop.first %}if{% else %}elif{% endif %} function_name == "{{ fn }}":
headers, output = await self.{{ function_name }}(message.header, {{ function_name
}}__Input_.from_pseudo_json(message.body))
return uapi.Message.Message(headers, output.to_pseudo_json())
{%- endfor %}

raise Exception("Unknown function: " + function_name)