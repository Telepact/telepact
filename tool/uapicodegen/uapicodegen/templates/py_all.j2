import keyword
from typing import Callable, TypeVar
from dataclasses import dataclass
from typing import cast, ForwardRef
from abc import ABC, abstractmethod


T = TypeVar('T')
U = TypeVar('U')

def util_let(value: T, f: Callable[[T], U]) -> U:
    return f(value)

class Undefined:
    pass


{%- macro to_py_type(t, append_nullable=True) %}
    {%- set nullable = '?' in t[0] -%}
    {%- set typ = t[0] | replace('?', '') -%}
    {%- if typ == 'array' -%}
        list[{{ to_py_type(t[1:][0]) }}]
    {%- elif typ == 'object' -%}
        dict[str, {{ to_py_type(t[1:][0]) }}]
    {%- elif typ == 'boolean' -%}
        bool
    {%- elif typ == 'integer' -%}
        int
    {%- elif typ == 'number' -%}
        float
    {%- elif typ == 'string' -%}
        str
    {%- elif typ == 'any' -%}
        object
    {%- elif typ.startswith('fn.') -%}
        {{ typ | regex_replace('^.*\\.', '') -}}__Input_
    {%- else -%}
        {{ typ | regex_replace('^.*\\.', '') -}}
    {%- endif -%}
    {%- if append_nullable and nullable %} | None{%- endif -%}
{%- endmacro -%}

{%- macro marshall_py_type(t, depth) -%}
    {%- set nullable = '?' in t[0] %}
    {%- set typ = t[0] | replace('?', '') -%}
    {%- if typ == 'array' -%}
        util_let(cast({{ to_py_type(t) }}, {{ caller() }}), lambda d{{depth}}: {% if nullable %}None if d{{depth}} is None else {% endif %}[{% call marshall_py_type(t[1:][0], depth + 1) %}e{{ depth }}{% endcall %} for e{{depth}} in d{{depth}}])
    {%- elif typ == 'object' -%}
        util_let(cast({{ to_py_type(t) }}, {{ caller() }}), lambda d{{depth}}: {% if nullable %}None if d{{depth}} is None else {% endif %}{ k{{depth}}: {%- call marshall_py_type(t[1:][0], depth + 1) %}v{{ depth }}{% endcall %} for k{{depth}}, v{{depth}} in d{{depth}}.items() })
    {%- elif typ.startswith('struct') or typ.startswith('fn') -%}
        util_let({{ caller() }}, lambda d{{ depth }}: {% if nullable %}None if d{{depth}} is None else {% endif %}{{ to_py_type(t, False) }}.from_pseudo_json(cast(dict[str, object], d{{ depth }})))
    {%- elif typ.startswith('union') -%}
        util_let({{ caller() }}, lambda d{{ depth }}: {% if nullable %}None if d{{depth}} is None else {% endif %}{{ to_py_type(t, False) }}.from_pseudo_json(cast(dict[str, object], d{{depth}})))
    {%- else -%}
        cast({{ to_py_type(t) }}, {{ caller() }})
    {%- endif -%}
{%- endmacro -%}

{%- macro unmarshall_py_type(t, depth) -%}
    {%- set typ = t[0] | replace('?', '') -%}
    {%- if typ == 'array' -%}
        util_let({{ caller() }}, lambda d{{depth}}: None if d{{depth}} is None else [{% call unmarshall_py_type(t[1:][0], depth + 1 )%}e{{ depth }}{% endcall %} for e{{depth}} in d{{depth}}])
    {%- elif typ == 'object' -%}
        util_let({{ caller() }}, lambda d{{depth}}: None if d{{depth}} is None else { k{{depth}}: {%- call unmarshall_py_type(t[1:][0], depth + 1) %}v{{ depth }}{% endcall %} for k{{depth}}, v{{depth}} in d{{depth}}.items()})
    {%- elif typ.startswith('struct') or typ.startswith('fn') or typ.startswith('union') -%}
        util_let({{ caller() }}, lambda d{{depth}}: None if d{{depth}} is None else d{{depth}}.to_pseudo_json())
    {%- else -%}
        {{ caller() }}
    {%- endif -%}
{%- endmacro -%}

{%- macro to_maybe_opt_py_type(type, field_name) -%}
    {%- if '!' in field_name -%}
        {{- to_py_type(type) }} | Undefined
    {%- else %}
        {{- to_py_type(type) }}
    {%- endif %}
{%- endmacro -%}

{%- macro marshall_py_type_maybe_opt(field_name, field_type) -%}
    {%- if '!' in field_name -%}
        Undefined() if '{{- field_name }}' not in map_ else {% call marshall_py_type(field_type, 0) %}map_["{{ field_name }}"]{% endcall %}
    {%- else %}
        {%- call marshall_py_type(field_type, 0) %}map_["{{ field_name }}"]{% endcall %}
    {%- endif %}
{%- endmacro -%}

{%- macro setter_maybe_opt(field_name) -%}
    {{ caller() }}
{%- endmacro -%}

{%- macro docstring(data) -%}
    {%- if '///' in data %}
'''
        {%- set doc = data['///'] -%}
        {%- if doc is iterable and doc is not string -%}
            {%- for line in doc %}
{{ line }}
            {%- endfor %}
        {%- else %}
{{ doc }}
        {%- endif %}
'''
    {%- endif %}
{%- endmacro -%}

{%- macro sanitize_field_name(field_name) -%}
    {%- set sanitized_name =  field_name | replace('!', '') -%}
    {%- set py_keywords = ['False', 'None', 'True', 'and', 'as', 'assert', 'async', 'await', 'break', 'class', 'continue', 'def', 'del', 'elif', 'else', 'except', 'finally', 'for', 'from', 'global', 'if', 'import', 'in', 'is', 'lambda', 'nonlocal', 'not', 'or', 'pass', 'raise', 'return', 'try', 'while', 'with', 'yield'] %}
    {%- if sanitized_name in py_keywords -%}
        {{- sanitized_name + '_' -}}
    {%- else -%}
        {{- sanitized_name -}}
    {%- endif -%}
{%- endmacro -%}

{%- macro case_type_display(type_display, case_key) %}
    {{- type_display + ('_' if type_display.endswith('_') else '__') + case_key }}
{%- endmacro %}

{%- macro struct(data, schema_key, alt_name, modifier, implements, unionCase, fn, typ_pref, type_display) %}
    {%- set fields = data[schema_key] %}
    {%- set py_name = alt_name if alt_name else schema_key | regex_replace('^.*\\.', '') %}
    {%- set type_str = typ_pref + py_name if typ_pref else py_name %}
@dataclass
class {{ type_display }}{% if implements %}({{ implements }}){% endif %}:
    {{ docstring(data) | indent }}

    {%- for field_name, field_type in fields.items() %}
    {{ sanitize_field_name(field_name) }}: '{{ to_maybe_opt_py_type(field_type, field_name) }}'{% if '!' in field_name %} = Undefined(){% endif %} # type: ignore
    {%- endfor %}

    @classmethod
    def from_pseudo_json(cls, map_{% if fn %}init{% endif %}: dict[str, object]) -> '{{ type_display }}':
        {%- if fn %}
        map_ = cast(dict[str, object], map_init["{{ unionCase }}"])
        {%- endif %}
        return cls(
            {%- for field_name, field_type in fields.items() %}
            {{ sanitize_field_name(field_name) }} = {{ marshall_py_type_maybe_opt(field_name, field_type) }},
            {%- endfor %}
        )

    def to_pseudo_json(self) -> dict[str, object]:
        fields: dict[str, object] = {}
        {%- for field_name, field_type in fields.items() %}
            {%- if '!' in field_name %}
        if not isinstance(self.{{ sanitize_field_name(field_name) }}, Undefined):
            fields["{{ field_name }}"] =  {% call unmarshall_py_type(field_type, 0) %}self.{{ sanitize_field_name(field_name) }}{% endcall %}
            {%- else %}
        fields["{{ field_name }}"] =  {% call unmarshall_py_type(field_type, 0) %}self.{{ sanitize_field_name(field_name) }}{% endcall %}
            {%- endif %}
        {%- endfor %}
        {%- if unionCase %}
        return {
            "{{ unionCase }}": fields
        }
        {%- else %}
        return fields
        {%- endif %}
{%- endmacro %}

{%- macro union(data, schema_key, fn, type_display) %}
    {%- set cases = data[schema_key] %}
    {%- if schema_key == '->' %}
        {%- set schema_key = 'Output' %}
    {%- endif %}
    {%- set py_name = schema_key | regex_replace('^.*\\.', '') %}
    {%- set super_class = fn + '_output_type_' if fn else py_name + '_type_' %}
    {%- set typ_pref = fn + '__Output__' if fn else py_name + '__'%}
    {%- set type_str = typ_pref + py_name %}

class {{ type_display }}(ABC):
    {{ docstring(data) | indent }}

    {%- set final_fn = fn + '.' if fn else '' %}

    @staticmethod
    def from_pseudo_json(map_: dict[str, object]) -> '{{ type_display }}':
        entry = next(iter(map_.items()))
        case_name = entry[0]
        payload = cast(dict[str, object], entry[1])
        if case_name == "NoMatch_":
            return cast({{ type_display }}, {{ case_type_display(type_display, 'NoMatch_') }}.from_pseudo_json(payload))
        {%- for case_entry in cases %}
            {% set case_key = case_entry | find_case_key %}
        elif case_name == "{{ case_key }}":
            return cast({{ type_display }}, {{ case_type_display(type_display, case_key) }}.from_pseudo_json(payload))
        {%- endfor %}
        else:
            return cast({{ type_display }}, {{ case_type_display(type_display, 'NoMatch_') }}.from_pseudo_json(payload))
    
    @abstractmethod
    def to_pseudo_json(self) -> dict[str, object]:
        raise NotImplementedError()

{{ struct({'NoMatch_': {} }, 'NoMatch_', None, 'final ', type_display, 'NoMatch_', fn, typ_pref, case_type_display(type_display, 'NoMatch_'))}}

{%- for case_entry in cases %}
    {% set case_key = case_entry | find_case_key %}
    {% set case_type_display_res = case_type_display(type_display, case_key) %}
    {{ struct(case_entry, case_key, None, 'final ', type_display, case_key, fn, typ_pref, case_type_display_res) }}
{%- endfor %}
{%- endmacro %}

{%- macro function(data, schema_key, type_display) %}
    {%- set fields = data[schema_key] %}
    {%- set py_name = schema_key | regex_replace('^.*\\.', '') %}
    {% do data.pop('///', None) %}

    {{ struct(data, schema_key, 'Input', 'static ', None, schema_key, py_name, py_name + '.', type_display + '__Input_') }}

    {{ union (data, '->', py_name, py_name + '__Output_')}}
{%- endmacro %}

{%- for schema_entry in input %}
    {%- set schema_key = schema_entry | find_schema_key %}

    {% set py_name = schema_key | regex_replace('^.*\\.', '') %}
    {%- if schema_key.startswith('struct') %}
        {{- struct(schema_entry, schema_key, None, "", None, None, None, None, py_name) }}
    {%- elif schema_key.startswith('union') %}
        {{- union(schema_entry, schema_key, None, py_name) }}
    {%- elif schema_key.startswith('fn') %}
        {{ function(schema_entry, schema_key, py_name) }}
    {%- endif %}
{% endfor %}

import uapi.Message
import uapi.Client

class ClientInterface_:

    client: uapi.Client.Client

    def __init__(self, client: uapi.Client.Client):
        self.client = client

    {% for fn in functions %}
    {%- set function_name = fn | replace('fn.', '') %}
    def {{ function_name }}(self, headers: dict[str, object], input: {{ function_name }}__Input_) -> {{ function_name }}__Output_:
        message = self.client.request(uapi.Message.Message(headers, input.to_pseudo_json()))
        return {{ function_name }}__Output_.from_pseudo_json(message.body)
    {%- endfor %}


class ServerHandler_:

    {%- for fn in functions %}
    {%- set function_name = fn | replace('fn.', '') %}
    def {{function_name}}(self, headers: dict[str, object], input: {{ function_name }}__Input_) -> {{ function_name }}__Output_:
        raise NotImplementedError()
    {%- endfor %}

    def handler(self, message: uapi.Message.Message) -> uapi.Message.Message:
        function_name = next(iter(message.body.keys()))

        {%- for fn in functions %}
        {%- set function_name = fn | replace('fn.', '') %}
        {% if loop.first %}
        if function_name == "{{ fn }}":
            output = self.{{ function_name }}(message.header, {{ function_name }}__Input_.from_pseudo_json(message.body))
            return uapi.Message.Message({}, output.to_pseudo_json())
        {% else %}
        elif function_name == "{{ fn }}":
            output = self.{{ function_name }}(message.header, {{ function_name }}__Input_.from_pseudo_json(message.body))
            return uapi.Message.Message({}, output.to_pseudo_json())
        {% endif %}
        {%- endfor %}

        raise Exception("Unknown function: " + function_name)
