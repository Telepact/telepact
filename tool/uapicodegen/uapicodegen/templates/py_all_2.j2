import keyword
from typing import Callable, TypeVar, Union, Literal, Generic, NoReturn, Never
from dataclasses import dataclass
from typing import cast, ForwardRef
import uapi.Message
import uapi.Client
from typing import Tuple


T = TypeVar('T')
U = TypeVar('U')


def util_let(value: T, f: Callable[[T], U]) -> U:
    return f(value)


class Undefined:
    pass


class TaggedValue_(Generic[T, U]):
    tag: T
    value: U

    def __init__(self, tag: T, value: U) -> None:
        self.tag_ = tag
        self.value_ = value

{% macro to_py_type(t, append_nullable=True) %}
    {%- set nullable = '?' in t[0] -%}
    {%- set typ = t[0] | replace('?', '') -%}
    {%- if typ == 'array' -%}
        list[{{ to_py_type(t[1:][0]) }}]
    {%- elif typ == 'object' -%}
        dict[str, {{ to_py_type(t[1:][0]) }}]
    {%- elif typ == 'boolean' -%}
        bool
    {%- elif typ == 'integer' -%}
        int
    {%- elif typ == 'number' -%}
        float
    {%- elif typ == 'string' -%}
        str
    {%- elif typ == 'any' -%}
        object
    {%- elif typ.startswith('fn.') -%}
        {{ typ | regex_replace('^.*\\.', '') -}}.Input
    {%- else -%}
        {{ typ | regex_replace('^.*\\.', '') -}}
    {%- endif -%}
    {%- if append_nullable and nullable %} | None{%- endif -%}
{%- endmacro -%}

{%- macro marshall_py_type(t, depth) -%}
    {%- set nullable = '?' in t[0] %}
    {%- set typ = t[0] | replace('?', '') -%}
    {%- if typ == 'array' -%}
        util_let(cast({{ to_py_type(t) }}, {{ caller() }}), lambda d{{depth}}: {% if nullable %}None if d{{depth}} is None else {% endif %}[{% call marshall_py_type(t[1:][0], depth + 1) %}e{{ depth }}{% endcall %} for e{{depth}} in d{{depth}}])
    {%- elif typ == 'object' -%}
        util_let(cast({{ to_py_type(t) }}, {{ caller() }}), lambda d{{depth}}: {% if nullable %}None if d{{depth}} is None else {% endif %}{ k{{depth}}: {%- call marshall_py_type(t[1:][0], depth + 1) %}v{{ depth }}{% endcall %} for k{{depth}}, v{{depth}} in d{{depth}}.items() })
    {%- elif typ.startswith('struct') or typ.startswith('fn') -%}
        util_let({{ caller() }}, lambda d{{ depth }}: {% if nullable %}None if d{{depth}} is None else {% endif %}{{ to_py_type(t, False) }}(cast(dict[str, object], d{{ depth }})))
    {%- elif typ.startswith('union') -%}
        util_let({{ caller() }}, lambda d{{ depth }}: {% if nullable %}None if d{{depth}} is None else {% endif %}{{ to_py_type(t, False) }}(cast(dict[str, object], d{{depth}})))
    {%- else -%}
        cast({{ to_py_type(t) }}, {{ caller() }})
    {%- endif -%}
{%- endmacro -%}

{%- macro unmarshall_py_type(t, depth) -%}
    {%- set typ = t[0] | replace('?', '') -%}
    {%- if typ == 'array' -%}
        util_let({{ caller() }}, lambda d{{depth}}: None if d{{depth}} is None else [{% call unmarshall_py_type(t[1:][0], depth + 1 )%}e{{ depth }}{% endcall %} for e{{depth}} in d{{depth}}])
    {%- elif typ == 'object' -%}
        util_let({{ caller() }}, lambda d{{depth}}: None if d{{depth}} is None else { k{{depth}}: {%- call unmarshall_py_type(t[1:][0], depth + 1) %}v{{ depth }}{% endcall %} for k{{depth}}, v{{depth}} in d{{depth}}.items()})
    {%- elif typ.startswith('struct') or typ.startswith('fn') or typ.startswith('union') -%}
        util_let({{ caller() }}, lambda d{{depth}}: None if d{{depth}} is None else d{{depth}}.pseudo_json)
    {%- else -%}
        {{ caller() }}
    {%- endif -%}
{%- endmacro -%}

{%- macro to_maybe_opt_py_type(type, field_name) -%}
    {%- if '!' in field_name -%}
        {{- to_py_type(type) }} | Undefined
    {%- else %}
        {{- to_py_type(type) }}
    {%- endif %}
{%- endmacro -%}

{%- macro setter_maybe_opt(field_name) -%}
    {{ caller() }}
{%- endmacro -%}

{%- macro docstring(doc) -%}
    {%- if doc -%}
'''
        {%- if doc is iterable and doc is not string -%}
            {%- for line in doc %}
{{ line }}
            {%- endfor %}
        {%- else %}
{{ doc }}
        {%- endif %}
'''
    {%- endif %}
{%- endmacro -%}

{%- macro sanitize_field_name(field_name) -%}
    {%- set sanitized_name =  field_name | replace('!', '') -%}
    {%- set py_keywords = ['bool', 'int', 'str', 'False', 'None', 'True', 'and', 'as', 'assert', 'async', 'await', 'break', 'class', 'continue', 'def', 'del', 'elif', 'else', 'except', 'finally', 'for', 'from', 'global', 'if', 'import', 'in', 'is', 'lambda', 'nonlocal', 'not', 'or', 'pass', 'raise', 'return', 'try', 'while', 'with', 'yield'] %}
    {%- if sanitized_name in py_keywords -%}
        {{- sanitized_name + '_' -}}
    {%- else -%}
        {{- sanitized_name -}}
    {%- endif -%}
{%- endmacro -%}

{%- macro struct(type_display, doc, fields, type_prefix) %}
class {{ type_display }}:
    {{ docstring(doc) | indent }}
    pseudo_json: dict[str, object]

    def __init__(self, pseudo_json: dict[str, object]) -> None:
        self.pseudo_json = pseudo_json

    @staticmethod
    def from_typed(
        {%- for field_name, field_type in fields.items() %}
            {%- if '!' not in field_name %}
        {{ sanitize_field_name(field_name) }}: '{{ to_maybe_opt_py_type(field_type, field_name) }}'{% if '!' in field_name %} = Undefined(){% endif %},
            {%- endif %}
        {%- endfor %}
        {%- for field_name, field_type in fields.items() %}
            {%- if '!' in field_name %}
        {{ sanitize_field_name(field_name) }}: '{{ to_maybe_opt_py_type(field_type, field_name) }}'{% if '!' in field_name %} = Undefined(){% endif %},
            {%- endif %}
        {%- endfor %}
    ) -> '{{ type_prefix + type_display }}':
        return {{ type_prefix + type_display }}({
            {%- for field_name, field_type in fields.items() %}
            "{{ field_name }}": {{ sanitize_field_name(field_name) }},
            {%- endfor %}
        })
    {% for field_name, field_type in fields.items() %}
    def {{ sanitize_field_name(field_name) }}(self) -> '{{ to_maybe_opt_py_type(field_type, field_name) }}':
        return {% call marshall_py_type(field_type, 0) %}self.pseudo_json["{{ field_name }}"]{% endcall %}
    {% endfor -%}
{%- endmacro -%}

{%- macro union(type_display, doc, tags, type_prefix) %}
    {%- set tag_prefix = type_prefix + type_display + '.' %}
class {{ type_display }}:
    {{ docstring(doc) | indent }}
    pseudo_json: dict[str, object]

    def __init__(self, pseudo_json: dict[str, object]) -> None:
        self.pseudo_json = pseudo_json
    {% for tag_entry in tags %}
        {%- set tag_key = tag_entry | find_tag_key %}
    @staticmethod
    def from_{{ tag_key }}(payload: '{{ tag_prefix + tag_key }}') -> '{{ type_prefix + type_display }}':
        return {{ type_prefix + type_display }}({
            "{{ tag_key }}": payload
        })
    {% endfor %}
    def get_tagged_value(self) -> Union[
        {%- for tag_entry in tags %}
            {%- set tag_key = tag_entry | find_tag_key %}
            TaggedValue_[Literal["{{ tag_key }}"], '{{ tag_prefix + tag_key }}'], 
        {%- endfor %}
            TaggedValue_[Literal["Unknown_"], dict[str, object]]]:
        
        tag = next(iter(self.pseudo_json.keys()))
        {%- for tag_entry in tags %}
            {%- set tag_key = tag_entry | find_tag_key %}
        {% if loop.first %}if{% else %}elif{% endif %} tag == "{{ tag_key }}":
            return TaggedValue_(cast(Literal["{{ tag_key }}"], "{{ tag_key }}"), {{ tag_prefix + tag_key }}(cast(dict[str, object], self.pseudo_json["{{ tag_key }}"])))
            {%- endfor %}
        else:
            return TaggedValue_(cast(Literal["Unknown_"], "Unknown_"), cast(dict[str, object], self.pseudo_json["{{ tag_key }}"]))
{% for tag_entry in tags %}
    {%- set tag_key = tag_entry | find_tag_key %}
    {{- struct(tag_key, tag_entry['///'], tag_entry[tag_key], tag_prefix) | indent }}
{%- endfor %}
{%- endmacro %}

{%- macro function(type_display, data, schema_key) %}
class {{ type_display }}:
    {{- struct('Input', data['///'], data[schema_key], type_display + '.') | indent }}
    {{- union ('Output', data['///'], data['->'], type_display + '.') | indent }}
{%- endmacro %}

{%- for schema_entry in input %}
    {%- set schema_key = schema_entry | find_schema_key %}

    {%- set py_name = schema_key | regex_replace('^.*\\.', '') %}
    {%- if schema_key.startswith('struct') %}
        {{- struct(py_name, schema_entry['///'], schema_entry[schema_key], '') }}
    {%- elif schema_key.startswith('union') %}
        {{- union(py_name, schema_entry['///'], schema_entry[schema_key], '') }}
    {%- elif schema_key.startswith('fn') %}
        {{- function(py_name, schema_entry,schema_key) }}
    {%- endif %}
{% endfor %}
class ClientInterface_:

    client: uapi.Client.Client

    def __init__(self, client: uapi.Client.Client):
        self.client = client
    {% for fn in functions %}
    {%- set function_name = fn | replace('fn.', '') %}
    async def {{ function_name }}(self, headers: dict[str, object], input: {{ function_name }}.Input) -> Tuple[dict[str, object], {{ function_name }}.Output]:
        message = await self.client.request(uapi.Message.Message(headers, input.pseudo_json))
        return message.headers, {{ function_name }}.Output(message.body)
    {% endfor %}

class ServerHandler_:

    {%- for fn in functions %}
    {%- set function_name = fn | replace('fn.', '') %}
    async def {{function_name}}(self, headers: dict[str, object], input: {{ function_name }}.Input) -> Tuple[dict[str, object], {{ function_name }}.Output]:
        raise NotImplementedError()
    {% endfor %}
    async def handler(self, message: uapi.Message.Message) -> uapi.Message.Message:
        function_name = next(iter(message.body.keys()))

        {%- for fn in functions %}
        {%- set function_name = fn | replace('fn.', '') %}
        {% if loop.first %}if{% else %}elif{% endif %} function_name == "{{ fn }}":
            headers, {{ function_name }}_output = await self.{{ function_name }}(message.headers, {{ function_name }}.Input(message.body))
            return uapi.Message.Message(headers, {{ function_name }}_output.pseudo_json)
        {% endfor %}
        raise Exception("Unknown function: " + function_name)
