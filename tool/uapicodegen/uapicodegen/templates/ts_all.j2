{%- macro to_ts_type(t, append_nullable=True) %}
    {%- set nullable = '?' in t[0] -%}
    {%- set typ = t[0] | replace('?', '') -%}
    {%- if typ == 'array' -%}
        Array<{{ to_ts_type(t[1:][0]) }}>
    {%- elif typ == 'object' -%}
        Record<, {{ to_ts_type(t[1:][0]) }}>
    {%- elif typ == 'boolean' -%}
        boolean
    {%- elif typ == 'integer' -%}
        number
    {%- elif typ == 'number' -%}
        number
    {%- elif typ == 'string' -%}
        string
    {%- elif typ == 'any' -%}
        any
    {%- elif typ.startswith('fn.') -%}
        {{ typ | regex_replace('^.*\\.', '') -}}Input
    {%- else -%}
        {{ typ | regex_replace('^.*\\.', '') -}}
    {%- endif -%}
    {%- if append_nullable and nullable %} | null{%- endif -%}
{%- endmacro -%}

{%- macro marshall_ts_type(t, depth) -%}
    {%- set nullable = '?' in t[0] %}
    {%- set typ = t[0] | replace('?', '') -%}
    {%- if typ == 'array' -%}
        {{ caller() }}.map((e{{ depth }}: any) => {% call marshall_ts_type(t[1:][0], depth + 1) %}e{{ depth }}{% endcall %})
    {%- elif typ == 'object' -%}
        Object.fromEntries(Object.entries({{ caller() }}).map(([k{{ depth }}, v{{ depth }}]: [string, any]) => [k{{ depth }}, {% call marshall_ts_type(t[1:][0], depth + 1) %}v{{ depth }}{% endcall %}]))
    {%- elif typ.startswith('struct') or typ.startswith('fn') -%}
        {{ to_ts_type(t, False) }}.fromPseudoJson({{ caller() }})
    {%- elif typ.startswith('union') -%}
        {{ to_ts_type(t, False) }}.fromPseudoJson({{ caller() }})
    {%- else -%}
        {{ caller() }}
    {%- endif -%}
{%- endmacro -%}

{%- macro unmarshall_ts_type(t, depth) -%}
    {%- set typ = t[0] | replace('?', '') -%}
    {%- if typ == 'array' -%}
        {{ caller() }}.map((e{{ depth }}: any) => {% call unmarshall_ts_type(t[1:][0], depth + 1) %}e{{ depth }}{% endcall %})
    {%- elif typ == 'object' -%}
        Object.fromEntries(Object.entries({{ caller() }}).map(([k{{ depth }}, v{{ depth }}]: [string, any]) => [k{{ depth }}, {% call unmarshall_ts_type(t[1:][0], depth + 1) %}v{{ depth }}{% endcall %}]))
    {%- elif typ.startswith('struct') or typ.startswith('fn') or typ.startswith('union') -%}
        {{ caller() }}.toPseudoJson()
    {%- else -%}
        {{ caller() }}
    {%- endif -%}
{%- endmacro -%}

{%- macro to_maybe_opt_ts_type(type, field_name) -%}
    {%- if '!' in field_name -%}
        {{- to_ts_type(type) }} | undefined
    {%- else %}
        {{- to_ts_type(type) }}
    {%- endif %}
{%- endmacro -%}

{%- macro marshall_py_type_maybe_opt(field_name, field_type) -%}
    {%- call marshall_py_type(field_type, 0) %}map_["{{ field_name }}"]{% endcall %}
{%- endmacro -%}

{%- macro setter_maybe_opt(field_name) -%}
    {{ caller() }}
{%- endmacro -%}

{%- macro docstring(data) -%}
    {%- if '///' in data %}
/**
        {%- set doc = data['///'] -%}
        {%- if doc is iterable and doc is not string -%}
            {%- for line in doc %}
 * {{ line }}
            {%- endfor %}
        {%- else %}
 * {{ doc }}
        {%- endif %}
 */
    {%- endif %}
{%- endmacro -%}

{%- macro sanitize_field_name(field_name) -%}
    {%- set sanitized_name = field_name | replace('!', '') -%}
    {%- set ts_keywords = ['break', 'case', 'catch', 'class', 'const', 'continue', 'debugger', 'default', 'delete', 'do', 'else', 'enum', 'export', 'extends', 'false', 'finally', 'for', 'function', 'if', 'import', 'in', 'instanceof', 'new', 'null', 'return', 'super', 'switch', 'this', 'throw', 'true', 'try', 'typeof', 'var', 'void', 'while', 'with', 'as', 'implements', 'interface', 'let', 'package', 'private', 'protected', 'public', 'static', 'yield', 'any', 'boolean', 'constructor', 'declare', 'get', 'module', 'require', 'number', 'set', 'string', 'symbol', 'type', 'from', 'of'] %}
    {%- if sanitized_name in ts_keywords -%}
        {{- sanitized_name + '_' -}}
    {%- else -%}
        {{- sanitized_name -}}
    {%- endif -%}
{%- endmacro -%}

{%- macro case_type_display(type_display, case_key) %}
    {{- type_display + ('_' if type_display.endswith('_') else '__') + case_key }}
{%- endmacro %}

{%- macro struct(data, schema_key, alt_name, modifier, implements, unionCase, fn, typ_pref, type_display) %}
    {%- set fields = data[schema_key] %}
    {%- set ts_name = alt_name if alt_name else schema_key | regex_replace('^.*\\.', '') %}
    {%- set type_str = typ_pref + ts_name if typ_pref else ts_name %}
export interface {{ type_display }}{% if implements %} extends {{ implements }}{% endif %} {
    {{ docstring(data) | indent }}

    {%- for field_name, field_type in fields.items() %}
    {{ sanitize_field_name(field_name) }}: {{ to_maybe_opt_ts_type(field_type, field_name) }};
    {%- endfor %}
}

export class {{ type_display }}Impl implements {{ type_display }} {
    {%- for field_name, field_type in fields.items() %}
    {{ sanitize_field_name(field_name) }}: {{ to_maybe_opt_ts_type(field_type, field_name) }};
    {%- endfor %}

    constructor(map_: any) {
        {%- for field_name, field_type in fields.items() %}
        this.{{ sanitize_field_name(field_name) }} = {% call marshall_ts_type(field_type, 0) %}map_["{{ field_name }}"]{% endcall %};
        {%- endfor %}
    }

    toPseudoJson(): any {
        const fields: any = {};
        {%- for field_name, field_type in fields.items() %}
        fields["{{ field_name }}"] = {% call unmarshall_ts_type(field_type, 0) %}this.{{ sanitize_field_name(field_name) }}{% endcall %};
        {%- endfor %}
        {%- if unionCase %}
        return {
            "{{ unionCase }}": fields
        };
        {%- else %}
        return fields;
        {%- endif %}
    }

    static fromPseudoJson(map_: any): {{ type_display }} {
        return new {{ type_display }}Impl(map_);
    }
}
{%- endmacro %}

{%- macro union(data, schema_key, fn, type_display) %}
    {%- set cases = data[schema_key] %}
    {%- if schema_key == '->' %}
        {%- set schema_key = 'Output' %}
    {%- endif %}
    {%- set ts_name = schema_key | regex_replace('^.*\\.', '') %}
    {%- set super_class = fn + '_output_type_' if fn else ts_name + '_type_' %}
    {%- set typ_pref = fn + '__Output__' if fn else ts_name + '__'%}
    {%- set type_str = typ_pref + ts_name %}

export type {{ type_display }} = 
    {%- for case_entry in cases %}
        {%- set case_key = case_entry | find_case_key %}
        {%- if not loop.first %} | {% endif %}
        {{ case_type_display(type_display, case_key) }}
    {%- endfor %};

export class {{ type_display }}Impl {
    {{ docstring(data) | indent }}

    static fromPseudoJson(map_: any): {{ type_display }} {
        const caseName = Object.keys(map_)[0];
        const payload = map_[caseName];
        if (caseName === "NoMatch_") {
            return {{ case_type_display(type_display, 'NoMatch_') }}Impl.fromPseudoJson(payload);
        }
        {%- for case_entry in cases %}
            {%- set case_key = case_entry | find_case_key %}
        else if (caseName === "{{ case_key }}") {
            return {{ case_type_display(type_display, case_key) }}Impl.fromPseudoJson(payload);
        }
        {%- endfor %}
        else {
            return {{ case_type_display(type_display, 'NoMatch_') }}Impl.fromPseudoJson(payload);
        }
    }

    abstract toPseudoJson(): any;
}

{{ struct({'NoMatch_': {} }, 'NoMatch_', None, 'final ', type_display, 'NoMatch_', fn, typ_pref, case_type_display(type_display, 'NoMatch_'))}}

{%- for case_entry in cases %}
    {%- set case_key = case_entry | find_case_key %}
    {%- set case_type_display_res = case_type_display(type_display, case_key) %}
    {{ struct(case_entry, case_key, None, 'final ', type_display, case_key, fn, typ_pref, case_type_display_res) }}
{%- endfor %}
{%- endmacro %}

{%- macro function(data, schema_key, type_display) %}
    {%- set fields = data[schema_key] %}
    {%- set ts_name = schema_key | regex_replace('^.*\\.', '') %}
    {% do data.pop('///', None) %}

    {{ struct(data, schema_key, 'Input', 'static ', None, schema_key, ts_name, ts_name + '.', type_display + '__Input_') }}

    {{ union (data, '->', ts_name, ts_name + '__Output_')}}
{%- endmacro %}

{%- for schema_entry in input %}
    {%- set schema_key = schema_entry | find_schema_key %}

    {% set ts_name = schema_key | regex_replace('^.*\\.', '') %}
    {%- if schema_key.startswith('struct') %}
        {{- struct(schema_entry, schema_key, None, "", None, None, None, None, ts_name) }}
    {%- elif schema_key.startswith('union') %}
        {{- union(schema_entry, schema_key, None, ts_name) }}
    {%- elif schema_key.startswith('fn') %}
        {{ function(schema_entry, schema_key, ts_name) }}
    {%- endif %}
{% endfor %}

import { Message, Client } from 'uapi';

class ClientInterface {

    client: Client;

    constructor(client: Client) {
        this.client = client;
    }

    {% for fn in functions %}
    {%- set function_name = fn | replace('fn.', '') %}
    {{ function_name }}(headers: Record<string, any>, input: {{ function_name }}__Input_): {{ function_name }}__Output_ {
        const message = this.client.request(new Message(headers, input.toPseudoJson()));
        return {{ function_name }}__Output_.fromPseudoJson(message.body);
    }
    {%- endfor %}
}

class ServerHandler {

    {%- for fn in functions %}
    {%- set function_name = fn | replace('fn.', '') %}
    {{ function_name }}(headers: Record<string, any>, input: {{ function_name }}__Input_): {{ function_name }}__Output_ {
        throw new Error("Not implemented");
    }
    {%- endfor %}

    handler(message: Message): Message {
        const functionName = Object.keys(message.body)[0];

        {%- for fn in functions %}
        {%- set function_name = fn | replace('fn.', '') %}
        {% if loop.first %}
        if (functionName === "{{ fn }}") {
            const output = this.{{ function_name }}(message.header, {{ function_name }}__Input_.fromPseudoJson(message.body));
            return new Message({}, output.toPseudoJson());
        }
        {% else %}
        else if (functionName === "{{ fn }}") {
            const output = this.{{ function_name }}(message.header, {{ function_name }}__Input_.fromPseudoJson(message.body));
            return new Message({}, output.toPseudoJson());
        }
        {% endif %}
        {%- endfor %}

        throw new Error("Unknown function: " + functionName);
    }
}
