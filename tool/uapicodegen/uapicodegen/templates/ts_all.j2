type Undefined = undefined;

function utilLet<T, U>(value: T, f: (value: T) => U): U {
    return f(value);
}

{%- macro to_ts_type(t, append_nullable=true) -%}
    {%- set nullable = '?' in t[0] -%}
    {%- set typ = t[0] | replace('?', '') -%}
    {%- if typ == 'array' -%}
        Array<{{ to_ts_type(t[1:][0]) }}>
    {%- elif typ == 'object' -%}
        Record<string, {{ to_ts_type(t[1:][0]) }}>
    {%- elif typ == 'boolean' -%}
        boolean
    {%- elif typ == 'integer' or typ == 'number' -%}
        number
    {%- elif typ == 'string' -%}
        string
    {%- elif typ == 'any' -%}
        any
    {%- elif typ.startswith('fn.') -%}
        {{ typ | regex_replace('^.*\\.', '') }}__Input_
    {%- else -%}
        {{ typ | regex_replace('^.*\\.', '') }}
    {%- endif -%}
    {%- if append_nullable and nullable %} | null{%- endif -%}
{%- endmacro -%}

{%- macro marshall_ts_type(t, depth) -%}
    {%- set nullable = '?' in t[0] %}
    {%- set typ = t[0] | replace('?', '') -%}
    {%- if typ == 'array' -%}
        utilLet(<{{ to_ts_type(t) }}>{{ caller() }}, d{{depth}} => {% if nullable %}d{{depth}} === null ? null : {% endif %}d{{depth}}.map(e{{depth}} => {% call marshall_ts_type(t[1:][0], depth + 1) %}e{{ depth }}{% endcall %}))
    {%- elif typ == 'object' -%}
        utilLet(<{{ to_ts_type(t) }}>{{ caller() }}, d{{depth}} => {% if nullable %}d{{depth}} === null ? null : {% endif %}Object.fromEntries(Object.entries(d{{depth}}).map(([k{{depth}}, v{{depth}}]) => [k{{depth}}, {% call marshall_ts_type(t[1:][0], depth + 1) %}v{{ depth }}{% endcall %}])))
    {%- elif typ.startswith('struct') or typ.startswith('fn') -%}
        utilLet({{ caller() }}, d{{ depth }} => {% if nullable %}d{{depth}} === null ? null : {% endif %}{{ to_ts_type(t, false) }}.fromPseudoJson(<Record<string, any>>d{{ depth }}))
    {%- elif typ.startswith('union') -%}
        utilLet({{ caller() }}, d{{ depth }} => {% if nullable %}d{{depth}} === null ? null : {% endif %}{{ to_ts_type(t, false) }}.fromPseudoJson(<Record<string, any>>d{{depth}}))
    {%- else -%}
        <{{ to_ts_type(t) }}>{{ caller() }}
    {%- endif -%}
{%- endmacro -%}

{%- macro unmarshall_ts_type(t, depth) -%}
    {%- set typ = t[0] | replace('?', '') -%}
    {%- if typ == 'array' -%}
        utilLet({{ caller() }}, d{{depth}} => d{{depth}} === null ? null : d{{depth}}.map(e{{depth}} => {% call unmarshall_ts_type(t[1:][0], depth + 1) %}e{{ depth }}{% endcall %}))
    {%- elif typ == 'object' -%}
        utilLet({{ caller() }}, d{{depth}} => d{{depth}} === null ? null : Object.fromEntries(Object.entries(d{{depth}}).map(([k{{depth}}, v{{depth}}]) => [k{{depth}}, {% call unmarshall_ts_type(t[1:][0], depth + 1) %}v{{ depth }}{% endcall %}])))
    {%- elif typ.startswith('struct') or typ.startswith('fn') or typ.startswith('union') -%}
        utilLet({{ caller() }}, d{{depth}} => d{{depth}} === null ? null : d{{depth}}.toPseudoJson())
    {%- else -%}
        {{ caller() }}
    {%- endif -%}
{%- endmacro -%}

{%- macro to_maybe_opt_ts_type(type, field_name) -%}
    {%- if '!' in field_name -%}
        {{- to_ts_type(type) }} | Undefined
    {%- else -%}
        {{- to_ts_type(type) }}
    {%- endif -%}
{%- endmacro -%}

{%- macro marshall_ts_type_maybe_opt(field_name, field_type) -%}
    {%- if '!' in field_name -%}
        map_['{{ field_name }}'] === undefined ? undefined : {% call marshall_ts_type(field_type, 0) %}map_["{{ field_name }}"]{% endcall -%}
    {%- else -%}
        {%- call marshall_ts_type(field_type, 0) %}map_["{{ field_name }}"]{% endcall -%}
    {%- endif -%}
{%- endmacro -%}

{%- macro setter_maybe_opt(field_name) -%}
    {{ caller() }}
{%- endmacro -%}

{%- macro docstring(data) -%}
    {%- if '///' in data %}
    /**
        {%- set doc = data['///'] -%}
        {%- if doc is iterable and doc is not string -%}
            {%- for line in doc %}
     * {{ line }}
            {%- endfor %}
        {%- else %}
     * {{ doc }}
        {%- endif %}
     */
    {%- endif -%}
{%- endmacro -%}

{%- macro sanitize_field_name(field_name) -%}
    {%- set sanitized_name =  field_name | replace('!', '') -%}
    {%- set ts_keywords = ['break', 'case', 'catch', 'class', 'const', 'continue', 'debugger', 'default', 'delete', 'do', 'else', 'enum', 'export', 'extends', 'false', 'finally', 'for', 'function', 'if', 'import', 'in', 'instanceof', 'new', 'null', 'return', 'super', 'switch', 'this', 'throw', 'true', 'try', 'typeof', 'var', 'void', 'while', 'with', 'yield'] %}
    {%- if sanitized_name in ts_keywords -%}
        {{- sanitized_name + '_' -}}
    {%- else -%}
        {{- sanitized_name -}}
    {%- endif -%}
{%- endmacro -%}

{%- macro case_type_display(type_display, case_key) -%}
    {{- type_display + ('_' if type_display.endswith('_') else '__') + case_key }}
{%- endmacro -%}

{%- macro struct(data, schema_key, alt_name, modifier, implements, unionCase, fn, typ_pref, type_display) -%}
    {%- set fields = data[schema_key] %}
    {%- set ts_name = alt_name if alt_name else schema_key | regex_replace('^.*\\.', '') %}
    {%- set type_str = typ_pref + ts_name if typ_pref else ts_name %}
export class {{ type_display }}{% if implements %} implements {{ implements }}{% endif %} {
    {{ docstring(data) | indent }}

    {%- for field_name, field_type in fields.items() %}
    {{ sanitize_field_name(field_name) }}: {{ to_maybe_opt_ts_type(field_type, field_name) }}{% if '!' in field_name %} = undefined{% endif %};
    {%- endfor %}

    constructor({
        {%- for field_name, field_type in fields.items() %}
        {%- if '!' in field_name %}
        {{ sanitize_field_name(field_name) }} = undefined,
        {%- else %}
        {{ sanitize_field_name(field_name) }},
        {%- endif %}
        {%- endfor %}
    }: {
        {%- for field_name, field_type in fields.items() %}
        {%- if '!' in field_name %}
        {{ sanitize_field_name(field_name) }}?: {{ to_maybe_opt_ts_type(field_type, field_name) }},
        {%- else %}
        {{ sanitize_field_name(field_name) }}: {{ to_maybe_opt_ts_type(field_type, field_name) }},
        {%- endif %}
        {%- endfor %}
    }) {
        {%- for field_name, field_type in fields.items() %}
        this.{{ sanitize_field_name(field_name) }} = {{ sanitize_field_name(field_name) }};
        {%- endfor %}
    }
    
    static fromPseudoJson(map_{% if fn %}init{% endif %}: Record<string, any>): {{ type_display }} {
        {%- if fn %}
        const map_ = <Record<string, any>>map_init["{{ unionCase }}"];
        {%- endif %}
        return new {{ type_display }}({
            {%- for field_name, field_type in fields.items() %}
            {{ sanitize_field_name(field_name) }}: {{ marshall_ts_type_maybe_opt(field_name, field_type) }},
            {%- endfor %}
        });
    }

    toPseudoJson(): Record<string, any> {
        const fields: Record<string, any> = {};
        {%- for field_name, field_type in fields.items() %}
            {%- if '!' in field_name %}
        if (this.{{ sanitize_field_name(field_name) }} !== undefined) {
            fields["{{ field_name }}"] = {% call unmarshall_ts_type(field_type, 0) %}this.{{ sanitize_field_name(field_name) }}{% endcall %};
        }
            {%- else %}
        fields["{{ field_name }}"] = {% call unmarshall_ts_type(field_type, 0) %}this.{{ sanitize_field_name(field_name) }}{% endcall %};
            {%- endif %}
        {%- endfor %}
        {%- if unionCase %}
        return {
            "{{ unionCase }}": fields
        };
        {%- else %}
        return fields;
        {%- endif %}
    }  
}
{% endmacro %}

{% macro union(data, schema_key, fn, type_display) %}
    {%- set cases = data[schema_key] %}
    {%- if schema_key == '->' %}
        {%- set schema_key = 'Output' %}
    {%- endif %}
    {%- set ts_name = schema_key | regex_replace('^.*\\.', '') %}
    {%- set super_class = fn + '_output_type_' if fn else ts_name + '_type_' %}
    {%- set typ_pref = fn + '__Output__' if fn else ts_name + '__'%}
    {%- set type_str = typ_pref + ts_name %}

export abstract class {{ type_display }} {
    {{ docstring(data) | indent }}

    {%- set final_fn = fn + '.' if fn else '' %}

    static fromPseudoJson(map_: Record<string, any>): {{ type_display }} {
        const entry = Object.entries(map_)[0]!;
        const case_name = entry[0];
        const payload = <Record<string, any>>entry[1];
        if (case_name === "NoMatch_") {
            return <{{ type_display }}>{{ case_type_display(type_display, 'NoMatch_') }}.fromPseudoJson(payload);
        }
        {%- for case_entry in cases %}
            {% set case_key = case_entry | find_case_key %}
        else if (case_name === "{{ case_key }}") {
            return <{{ type_display }}>{{ case_type_display(type_display, case_key) }}.fromPseudoJson(payload);
        }
        {%- endfor %}
        else {
            return <{{ type_display }}>{{ case_type_display(type_display, 'NoMatch_') }}.fromPseudoJson(payload);
        }
    }

    abstract toPseudoJson(): Record<string, any>;
}

{{ struct({'NoMatch_': {} }, 'NoMatch_', None, 'final ', type_display, 'NoMatch_', fn, typ_pref, case_type_display(type_display, 'NoMatch_'))}}

{%- for case_entry in cases %}
    {% set case_key = case_entry | find_case_key %}
    {% set case_type_display_res = case_type_display(type_display, case_key) %}
    {{ struct(case_entry, case_key, None, 'final ', type_display, case_key, fn, typ_pref, case_type_display_res) }}
{%- endfor %}
{% endmacro %}

{% macro function(data, schema_key, type_display) %}
    {%- set fields = data[schema_key] %}
    {%- set ts_name = schema_key | regex_replace('^.*\\.', '') %}
    {% do data.pop('///', None) %}

    {{ struct(data, schema_key, 'Input', 'static ', None, schema_key, ts_name, ts_name + '.', type_display + '__Input_') }}

    {{ union (data, '->', ts_name, ts_name + '__Output_')}}
{% endmacro %}

{% for schema_entry in input %}
    {%- set schema_key = schema_entry | find_schema_key %}

    {% set ts_name = schema_key | regex_replace('^.*\\.', '') %}
    {%- if schema_key.startswith('struct') %}
        {{- struct(schema_entry, schema_key, None, "", None, None, None, None, ts_name) }}
    {%- elif schema_key.startswith('union') %}
        {{- union(schema_entry, schema_key, None, ts_name) }}
    {%- elif schema_key.startswith('fn') %}
        {{ function(schema_entry, schema_key, ts_name) }}
    {%- endif %}
{% endfor %}

import {
    Client as uapi__Client,
    Message as uapi__Message
} from 'uapi';

export class ClientInterface_ {

    client: uapi__Client;

    constructor(client: uapi__Client) {
        this.client = client;
    }

    {% for fn in functions %}
    {%- set function_name = fn | replace('fn.', '') %}
    async {{ function_name }}(headers: Record<string, any>, input: {{ function_name }}__Input_): Promise<{{ function_name }}__Output_> {
        const message = await this.client.request(new uapi__Message(headers, input.toPseudoJson()));
        return {{ function_name }}__Output_.fromPseudoJson(message.body);
    }
    {%- endfor %}
}

export class ServerHandler_ {

    {% for fn in functions %}
    {%- set function_name = fn | replace('fn.', '') %}
    {{ function_name }}(headers: Record<string, any>, input: {{ function_name }}__Input_): {{ function_name }}__Output_ {
        throw new Error("Not implemented");
    }
    {%- endfor %}

    handler(message: uapi__Message): uapi__Message {
        const function_name = Object.keys(message.body)[0];

        {% for fn in functions %}
        {%- set function_name = fn | replace('fn.', '') -%}
        {%- if loop.first -%}
        if (function_name === "{{ fn }}") {
            const output = this.{{ function_name }}(message.header, {{ function_name }}__Input_.fromPseudoJson(message.body));
            return new uapi__Message({}, output.toPseudoJson());
        }
        {%- else -%}
        else if (function_name === "{{ fn }}") {
            const output = this.{{ function_name }}(message.header, {{ function_name }}__Input_.fromPseudoJson(message.body));
            return new uapi__Message({}, output.toPseudoJson());
        }
        {%- endif -%}
        {% endfor %}

        throw new Error("Unknown function: " + function_name);
    }
}
