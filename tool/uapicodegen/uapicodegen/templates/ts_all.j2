{%- macro to_ts_type(t, append_nullable=True) %}
    {%- set nullable = '?' in t[0] -%}
    {%- set typ = t[0] | replace('?', '') -%}
    {%- if typ == 'array' -%}
        Array<{{ to_ts_type(t[1:][0]) }}>
    {%- elif typ == 'object' -%}
        Record<string, {{ to_ts_type(t[1:][0]) }}>
    {%- elif typ == 'boolean' -%}
        boolean
    {%- elif typ == 'integer' or typ == 'number' -%}
        number
    {%- elif typ == 'string' -%}
        string
    {%- elif typ == 'any' -%}
        any
    {%- elif typ.startswith('fn.') -%}
        {{ typ | regex_replace('^.*\\.', '') }}Input
    {%- else -%}
        {{ typ | regex_replace('^.*\\.', '') }}
    {%- endif -%}
    {%- if append_nullable and nullable %} | null{%- endif -%}
{%- endmacro -%}

{%- macro marshall_ts_type(t, depth) -%}
    {%- set nullable = '?' in t[0] %}
    {%- set typ = t[0] | replace('?', '') -%}
    {%- if typ == 'array' -%}
        ((d{{ depth }}: {{ to_ts_type(t) }}) => {% if nullable %}d{{ depth }} === null ? null : {% endif %}d{{ depth }}.map((e{{ depth }}) => {% call marshall_ts_type(t[1:][0], depth + 1) %}e{{ depth }}{% endcall %}))({{ caller() }})
    {%- elif typ == 'object' -%}
        ((d{{ depth }}: {{ to_ts_type(t) }}) => {% if nullable %}d{{ depth }} === null ? null : {% endif %}Object.fromEntries(Object.entries(d{{ depth }}).map(([k{{ depth }}, v{{ depth }}]) => [k{{ depth }}, {% call marshall_ts_type(t[1:][0], depth + 1) %}v{{ depth }}{% endcall %}])))({{ caller() }})
    {%- elif typ.startswith('struct') or typ.startswith('fn') -%}
        ((d{{ depth }}: any) => {% if nullable %}d{{ depth }} === null ? null : {% endif %}{{ to_ts_type(t, False) }}.fromPseudoJson(d{{ depth }}))({{ caller() }})
    {%- elif typ.startswith('union') -%}
        ((d{{ depth }}: any) => {% if nullable %}d{{ depth }} === null ? null : {% endif %}{{ to_ts_type(t, False) }}.fromPseudoJson(d{{ depth }}))({{ caller() }})
    {%- else -%}
        {{ caller() }}
    {%- endif -%}
{%- endmacro -%}

{%- macro unmarshall_ts_type(t, depth) -%}
    {%- set nullable = '?' in t[0] %}
    {%- set typ = t[0] | replace('?', '') -%}
    {%- if typ == 'array' -%}
        ((d{{ depth }}) => {% if nullable %}d{{ depth }} === null ? null : {% endif %}d{{ depth }}.map((e{{ depth }}) => {% call unmarshall_ts_type(t[1:][0], depth + 1) %}e{{ depth }}{% endcall %}))({{ caller() }})
    {%- elif typ == 'object' -%}
        ((d{{ depth }}) => {% if nullable %}d{{ depth }} === null ? null : {% endif %}Object.fromEntries(Object.entries(d{{ depth }}).map(([k{{ depth }}, v{{ depth }}]) => [k{{ depth }}, {% call unmarshall_ts_type(t[1:][0], depth + 1) %}v{{ depth }}{% endcall %}])))({{ caller() }})
    {%- elif typ.startswith('struct') or typ.startswith('fn') or typ.startswith('union') -%}
        ((d{{ depth }}) => {% if nullable %}d{{ depth }} === null ? null : {% endif %}d{{ depth }}.toPseudoJson())({{ caller() }})
    {%- else -%}
        {{ caller() }}
    {%- endif -%}
{%- endmacro -%}

{%- macro to_maybe_opt_ts_type(type, field_name) -%}
    {%- if '!' in field_name -%}
        {{- to_ts_type(type) }} | undefined
    {%- else %}
        {{- to_ts_type(type) }}
    {%- endif %}
{%- endmacro -%}

{%- macro setter_maybe_opt(field_name) -%}
    {{ caller() }}
{%- endmacro -%}

{%- macro docstring(doc) -%}
    {%- if doc -%}
    /**
        {%- if doc is iterable and doc is not string -%}
            {%- for line in doc %}
     * {{ line }}
            {%- endfor %}
        {%- else %}
     * {{ doc }}
        {%- endif %}
     */
    {%- endif %}
{%- endmacro -%}

{%- macro sanitize_field_name(field_name) -%}
    {%- set sanitized_name =  field_name | replace('!', '') -%}
    {%- set ts_keywords = ['boolean', 'number', 'string', 'null', 'undefined', 'true', 'false', 'if', 'else', 'for', 'while', 'do', 'switch', 'case', 'default', 'break', 'continue', 'function', 'return', 'var', 'let', 'const', 'new', 'this', 'super', 'class', 'extends', 'import', 'export', 'implements', 'interface', 'public', 'private', 'protected', 'static', 'yield', 'async', 'await', 'try', 'catch', 'finally', 'throw', 'typeof', 'instanceof', 'void', 'delete', 'in', 'of', 'with'] %}
    {%- if sanitized_name in ts_keywords -%}
        {{- sanitized_name + '_' -}}
    {%- else -%}
        {{- sanitized_name -}}
    {%- endif -%}
{%- endmacro -%}

{%- macro case_type_display(type_display, case_key) %}
    {{- type_display + ('_' if type_display.endswith('_') else '__') + case_key }}
{%- endmacro %}

{%- macro struct(type_display, doc, fields, implements, union_case) %}
export class {{ type_display }}{% if implements %} implements {{ implements }}{% endif %} {
    {{ docstring(doc) | indent }}

    {%- for field_name, field_type in fields.items() %}
    {{ sanitize_field_name(field_name) }}: {{ to_maybe_opt_ts_type(field_type, field_name) }}{% if '!' in field_name %} = undefined{% endif %};
    {%- endfor %}

    constructor({
        {%- for field_name, field_type in fields.items() %}
        {{ sanitize_field_name(field_name) }}{% if '!' in field_name %} = undefined{% endif %},
        {%- endfor %}        
    }: {
        {%- for field_name, field_type in fields.items() %}
        {{ sanitize_field_name(field_name) }}: {{ to_maybe_opt_ts_type(field_type, field_name) }},
        {%- endfor %}        
    }) {
        {%- for field_name, field_type in fields.items() %}
        this.{{ sanitize_field_name(field_name) }} = {{ sanitize_field_name(field_name) }};
        {%- endfor %}
    }

    static fromPseudoJson(map_{% if union_case %}init{% endif %}: Record<string, any>): {{ type_display }} {
        {%- if union_case %}
        const map_ = map_init["{{ union_case }}"];
        {%- endif %}
        return new {{ type_display }}({
        {%- for field_name, field_type in fields.items() %}
            {{ sanitize_field_name(field_name) }}: {% if '!' in field_name %}!("{{ field_name}}" in map_) ? undefined : {% endif %}{% call marshall_ts_type(field_type, 0) %}map_["{{ field_name }}"]{% endcall %},
        {%- endfor %}
        });
    }

    toPseudoJson(): Record<string, any> {
        const fields: Record<string, any> = {};
        {%- for field_name, field_type in fields.items() %}
            {%- if '!' in field_name %}
        if (this.{{ sanitize_field_name(field_name) }} !== undefined) {
            fields["{{ field_name }}"] = {% call unmarshall_ts_type(field_type, 0) %}this.{{ sanitize_field_name(field_name) }}{% endcall %};
        }
            {%- else %}
        fields["{{ field_name }}"] = {% call unmarshall_ts_type(field_type, 0) %}this.{{ sanitize_field_name(field_name) }}{% endcall %};
            {%- endif %}
        {%- endfor %}
        {%- if union_case %}
        return {
            "{{ union_case }}": fields
        };
        {%- else %}
        return fields;
        {%- endif %}
    }
}
{%- endmacro %}

{%- macro no_match_struct(type_display, implements) %}
export class {{ type_display }}{% if implements %} implements {{ implements }}{% endif %} {
    original: Record<string, any>;

    static fromPseudoJson(map_: Record<string, any>): {{ type_display }} {
        return {{ type_display }}.fromPseudoJson(map_);
    }

    toPseudoJson(): Record<string, any> {
        return this.original;
    }
}
{%- endmacro %}

{%- macro union(type_display, doc, cases) %}
export abstract class {{ type_display }} {
    {{ docstring(doc) | indent }}

    static fromPseudoJson(map_: Record<string, any>): {{ type_display }} {
        const [caseName, payload] = Object.entries(map_)[0];
        {%- for case_entry in cases %}
            {% set case_key = case_entry | find_case_key %}
        {% if loop.first%}if{% else %}else if{% endif %} (caseName === "{{ case_key }}") {
            return {{ case_type_display(type_display, case_key) }}.fromPseudoJson(map_);
        }
        {%- endfor %}
        else {
            return {{ case_type_display(type_display, 'NoMatch_') }}.fromPseudoJson(map_);
        }
    }

    abstract toPseudoJson(): Record<string, any>;
}

{{ no_match_struct(case_type_display(type_display, 'NoMatch_'), type_display) }}

{%- for case_entry in cases %}
    {% set case_key = case_entry | find_case_key %}
    {% set case_type_display_res = case_type_display(type_display, case_key) %}
    {{ struct(case_type_display_res, case_entry['///'], case_entry[case_key], type_display, case_key) }}
{%- endfor %}
{%- endmacro %}

{%- macro function(type_display, data, schema_key) %}
    {{ struct(type_display + 'Input', data['///'], data[schema_key], None, schema_key) }}
    {{ union(type_display + 'Output', data['///'], data['->']) }}
{%- endmacro %}

{%- for schema_entry in input %}
    {%- set schema_key = schema_entry | find_schema_key %}
    {% set ts_name = schema_key | regex_replace('^.*\\.', '') %}
    {%- if schema_key.startswith('struct') %}
        {{ struct(ts_name, schema_entry['///'], schema_entry[schema_key], None, None) }}
    {%- elif schema_key.startswith('union') %}
        {{ union(ts_name, schema_entry['///'], schema_entry[schema_key]) }}
    {%- elif schema_key.startswith('fn') %}
        {{ function(ts_name, schema_entry, schema_key) }}
    {%- endif %}
{% endfor %}

import { Message, Client } from 'uapi';

export class ClientInterface {
    client: Client;

    constructor(client: Client) {
        this.client = client;
    }

    {% for fn in functions %}
    {%- set function_name = fn | replace('fn.', '') %}
    async {{ function_name }}(headers: Record<string, any>, input: {{ function_name }}Input): Promise<[ Record<string, any>, {{ function_name }}Output ]> {
        const message = await this.client.request(new Message(headers, input.toPseudoJson()));
        return [message.header, {{ function_name }}Output.fromPseudoJson(message.body)];
    }
    {%- endfor %}
}

export class ServerHandler {
    {%- for fn in functions %}
    {%- set function_name = fn | replace('fn.', '') %}
    {{ function_name }}(headers: Record<string, any>, input: {{ function_name }}Input): [ Record<string, any>, {{ function_name }}Output ] {
        throw new Error('Not implemented');
    }
    {%- endfor %}

    handler(message: Message): Message {
        const functionName = Object.keys(message.body)[0];

        {%- for fn in functions %}
        {%- set function_name = fn | replace('fn.', '') %}
        {% if loop.first %}if{% else %}else if{% endif %} (functionName === "{{ fn }}") {
            const [headers, output] = this.{{ function_name }}(message.header, {{ function_name }}Input.fromPseudoJson(message.body));
            return new Message(headers, output.toPseudoJson());
        }
        {%- endfor %}

        throw new Error("Unknown function: " + functionName);
    }
}
