package {{ package }};

import java.util.List;
import java.util.Map;

{%- macro to_java_type(t) %}
    {%- set typ = t | replace('?', '') %}
    {%- if typ == 'array' %}
        {{- 'List' -}}
    {%- elif typ == 'object' %}
        {{- 'Map' -}}
    {%- elif typ == 'boolean' %}
        {{- 'Boolean' -}}
    {%- elif typ == 'integer' %}
        {{- 'Integer' -}}
    {%- elif typ == 'number' %}
        {{- 'Number' -}}
    {%- elif typ == 'string' %}
        {{- 'String' -}}
    {%- else %}
        {{- t | regex_replace('^.*\\.', '') -}}
    {%- endif %}
{%- endmacro -%}

{%- macro translate(type) -%}
    {{- to_java_type(type[0]) -}}
    {%- if type | length > 1 -%}
        {{- '<' -}}
        {%- for t in type[1:] -%}
            {{- translate(t) -}}{{ ", " if not loop.last -}}
        {%- endfor -%}
        {{- '>' -}}
    {%- endif -%}
{%- endmacro -%}

{%- macro struct(data, schema_key, alt_name, modifier, implements) %}
    {%- set fields = data[schema_key] %}
    {%- set java_name = alt_name if alt_name else schema_key | regex_replace('^.*\\.', '') %}
    {%- if '///' in data %}
/**
{%- for line in data['///'] %}
 *{{ line }}
{%- endfor %}
 */
{%- endif %}
public {{ modifier }}class {{ java_name }}{% if '<1>' in schema_key %}{{ '<T0>' }}{% elif '2' in schema_key %}{{ '<T0, T1>'}}{% elif '<2>' in schema_key %}{{ '<T0, T1, T2>' }}{% endif %}{% if implements %} implements {{ implements }}{% endif %} {
    {%- for field_name, field_type in fields.items() %}
    public final {{ translate(field_type) }} {{ field_name }};
    {%- endfor %}

    public {{ java_name }}({% for field_name, field_type in fields.items() %}{{ translate(field_type) }} {{ field_name }}{% if not loop.last %}, {% endif %}{% endfor %}) {
        {%- for field_name, field_type in fields.items() %}
        this.{{ field_name }} = {{ field_name }};
        {%- endfor %}
    }
}
{%- endmacro %}

{%- macro union(data, schema_key) %}
    {%- set cases = data[schema_key] %}
    {%- if schema_key == '->' %}
        {%- set schema_key = 'Output' %}
    {%- endif %}
    {%- set java_name = schema_key | regex_replace('^.*\\.', '') %}
    {%- if '///' in data %}
/**
{%- for line in data['///'] %}
 *{{ line }}
{%- endfor %}
 */
{%- endif %}
public sealed interface {{ java_name }}{% if '<1>' in schema_key %}{{ '<T0>' }}{% elif '2' in schema_key %}{{ '<T0, T1>'}}{% elif '<2>' in schema_key %}{{ '<T0, T1, T2>' }}{% endif %} {

    {{ struct({'NO_MATCH_': {} }, 'NO_MATCH_', None, 'final ', java_name) | indent }}

    {%- for case_entry in cases %}
        {% set case_key = case_entry | find_case_key %}
        {{ struct(case_entry, case_key, None, 'final ', java_name) | indent }}
    {%- endfor %}
}
{%- endmacro %}

{%- macro function(data, schema_key) %}
    {%- set fields = data[schema_key] %}
    {%- set java_name = schema_key | regex_replace('^.*\\.', '') %}
public final class {{ java_name }} {

    {{ struct(data, schema_key, 'Input', 'static ', None) | indent }}

    {% do data.pop('///') %}

    {{ union (data, '->') | indent }}
}
{%- endmacro %}


{%- set schema_key = data | find_schema_key %}

{%- if schema_key.startswith('struct') %}
    {{ struct(data, schema_key, None, "", None) }}
{%- elif schema_key.startswith('union') %}
    {{ union(data, schema_key) }}
{%- elif schema_key.startswith('fn') %}
    {{ function(data, schema_key) }}
{%- endif %}

