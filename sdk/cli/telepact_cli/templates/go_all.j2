// Code generated by the Telepact CLI. DO NOT EDIT.
package {{ package }}

import (
    "errors"

    telepact "github.com/telepact/telepact/lib/go/telepact"
)

func cloneMap(src map[string]any) map[string]any {
    if src == nil {
        return map[string]any{}
    }
    dst := make(map[string]any, len(src))
    for k, v := range src {
        dst[k] = v
    }
    return dst
}

type TypedClient struct {
    client *telepact.Client
}

func NewTypedClient(client *telepact.Client) *TypedClient {
    return &TypedClient{client: client}
}

{% for fn in functions %}
type {{ fn.pascal_name }}Input struct {
    pseudoJSON map[string]any
}

func New{{ fn.pascal_name }}InputFromPseudoJSON(p map[string]any) {{ fn.pascal_name }}Input {
    return {{ fn.pascal_name }}Input{pseudoJSON: cloneMap(p)}
}

func (i {{ fn.pascal_name }}Input) PseudoJSON() map[string]any {
    return cloneMap(i.pseudoJSON)
}

type {{ fn.pascal_name }}Output struct {
    pseudoJSON map[string]any
}

func New{{ fn.pascal_name }}OutputFromPseudoJSON(p map[string]any) {{ fn.pascal_name }}Output {
    return {{ fn.pascal_name }}Output{pseudoJSON: cloneMap(p)}
}

func (o {{ fn.pascal_name }}Output) PseudoJSON() map[string]any {
    return cloneMap(o.pseudoJSON)
}

func (c *TypedClient) {{ fn.pascal_name }}(headers map[string]any, input {{ fn.pascal_name }}Input) (telepact.TypedMessage[{{ fn.pascal_name }}Output], error) {
    if c == nil || c.client == nil {
        return telepact.TypedMessage[{{ fn.pascal_name }}Output]{}, errors.New("telepact: typed client not configured")
    }

    request := telepact.NewMessage(headers, map[string]any{"{{ fn.key }}": input.PseudoJSON()})
    response, err := c.client.Request(request)
    if err != nil {
        return telepact.TypedMessage[{{ fn.pascal_name }}Output]{}, err
    }

    typed := New{{ fn.pascal_name }}OutputFromPseudoJSON(response.Body)
    return telepact.NewTypedMessage(response.Headers, typed), nil
}

{% endfor %}
func (c *TypedClient) Invoke(target string, headers map[string]any, payload map[string]any) (map[string]any, map[string]any, bool, error) {
    if c == nil || c.client == nil {
        return nil, nil, false, errors.New("telepact: typed client not configured")
    }

    switch target {
    {% for fn in functions %}case "{{ fn.key }}":
        result, err := c.{{ fn.pascal_name }}(headers, New{{ fn.pascal_name }}InputFromPseudoJSON(payload))
        if err != nil {
            return nil, nil, true, err
        }
        return result.Headers, result.Body.PseudoJSON(), true, nil
    {% endfor %}default:
        return nil, nil, false, nil
    }
}
