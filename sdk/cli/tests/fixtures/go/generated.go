

// Code generated by the Telepact CLI. DO NOT EDIT.
package output

import (
    "errors"
    "fmt"

    telepact "github.com/telepact/telepact/lib/go/telepact"
)

type Optional[T any] struct {
    value   T
    present bool
}

func Some[T any](value T) Optional[T] {
    return Optional[T]{value: value, present: true}
}

func None[T any]() Optional[T] {
    var zero T
    return Optional[T]{value: zero, present: false}
}

func (o Optional[T]) Value() (T, bool) {
    return o.value, o.present
}

type TaggedValue[T comparable, U any] struct {
    Tag   T
    Value U
}

type UntypedTaggedValue struct {
    Tag   string
    Value map[string]any
}

func cloneMap(src map[string]any) map[string]any {
    if src == nil {
        return map[string]any{}
    }
    dst := make(map[string]any, len(src))
    for k, v := range src {
        dst[k] = v
    }
    return dst
}

func identity[T any](value T) any {
    return any(value)
}

func encodeOptional[T any](opt Optional[T], encode func(T) any) (any, bool) {
    value, ok := opt.Value()
    if !ok {
        var zero any
        return zero, false
    }
    return encode(value), true
}

func encodeNullable[T any](ptr *T, encode func(T) any) any {
    if ptr == nil {
        return nil
    }
    return encode(*ptr)
}

func encodeSlice[T any](values []T, encode func(T) any) []any {
    if values == nil {
        return nil
    }
    out := make([]any, len(values))
    for i, v := range values {
        out[i] = encode(v)
    }
    return out
}

func encodeMap[T any](values map[string]T, encode func(T) any) map[string]any {
    if values == nil {
        return nil
    }
    out := make(map[string]any, len(values))
    for k, v := range values {
        out[k] = encode(v)
    }
    return out
}

func decodeSlice[T any](value any, decode func(any) T) []T {
    if value == nil {
        return nil
    }
    src := asSlice(value)
    out := make([]T, len(src))
    for i, v := range src {
        out[i] = decode(v)
    }
    return out
}

func decodeMap[T any](value any, decode func(any) T) map[string]T {
    if value == nil {
        return nil
    }
    src := asMap(value)
    out := make(map[string]T, len(src))
    for k, v := range src {
        out[k] = decode(v)
    }
    return out
}

func nullable[T any](value any, decode func(any) T) *T {
    if value == nil {
        return nil
    }
    result := decode(value)
    return &result
}

func asMap(value any) map[string]any {
    if value == nil {
        return map[string]any{}
    }
    switch typed := value.(type) {
    case map[string]any:
        return cloneMap(typed)
    case map[any]any:
        result := make(map[string]any, len(typed))
        for k, v := range typed {
            result[fmt.Sprint(k)] = v
        }
        return result
    default:
        panic(fmt.Sprintf("telepact: expected map[string]any, got %T", value))
    }
}

func asSlice(value any) []any {
    if value == nil {
        return nil
    }
    switch typed := value.(type) {
    case []any:
        return typed
    case []string:
        out := make([]any, len(typed))
        for i, v := range typed {
            out[i] = v
        }
        return out
    case []map[string]any:
        out := make([]any, len(typed))
        for i, v := range typed {
            out[i] = v
        }
        return out
    default:
        panic(fmt.Sprintf("telepact: expected slice, got %T", value))
    }
}

func asBool(value any) bool {
    if value == nil {
        return false
    }
    if typed, ok := value.(bool); ok {
        return typed
    }
    panic(fmt.Sprintf("telepact: expected bool, got %T", value))
}

func asInt(value any) int {
    switch typed := value.(type) {
    case int:
        return typed
    case int64:
        return int(typed)
    case int32:
        return int(typed)
    case float64:
        return int(typed)
    case float32:
        return int(typed)
    default:
        panic(fmt.Sprintf("telepact: expected integer, got %T", value))
    }
}

func asFloat64(value any) float64 {
    switch typed := value.(type) {
    case float64:
        return typed
    case float32:
        return float64(typed)
    case int:
        return float64(typed)
    case int64:
        return float64(typed)
    case int32:
        return float64(typed)
    default:
        panic(fmt.Sprintf("telepact: expected number, got %T", value))
    }
}

func asString(value any) string {
    if value == nil {
        return ""
    }
    if typed, ok := value.(string); ok {
        return typed
    }
    panic(fmt.Sprintf("telepact: expected string, got %T", value))
}

func asBytes(value any) []byte {
    if value == nil {
        return nil
    }
    if typed, ok := value.([]byte); ok {
        return typed
    }
    panic(fmt.Sprintf("telepact: expected []byte, got %T", value))
}

func appendUnique(list []string, value string) []string {
    for _, item := range list {
        if item == value {
            return list
        }
    }
    return append(list, value)
}

func ensureStringSlice(value any) []string {
    if value == nil {
        return []string{}
    }
    switch typed := value.(type) {
    case []string:
        return append([]string{}, typed...)
    case []any:
        result := make([]string, 0, len(typed))
        for _, v := range typed {
            result = append(result, fmt.Sprint(v))
        }
        return result
    default:
        panic(fmt.Sprintf("telepact: expected []string, got %T", value))
    }
}

func ensureStringMap(value any) map[string][]string {
    if value == nil {
        return map[string][]string{}
    }
    switch typed := value.(type) {
    case map[string][]string:
        result := make(map[string][]string, len(typed))
        for k, v := range typed {
            result[k] = append([]string{}, v...)
        }
        return result
    case map[string]any:
        result := make(map[string][]string, len(typed))
        for k, v := range typed {
            result[k] = ensureStringSlice(v)
        }
        return result
    default:
        panic(fmt.Sprintf("telepact: expected map[string][]string, got %T", value))
    }
}

func firstKey(m map[string]any) string {
    for k := range m {
        return k
    }
    return ""
}

// hello world
// 
// This is the result.
type Example1 struct {
    pseudoJSON map[string]any
}

func NewExample1FromPseudoJSON(p map[string]any) Example1 {
    return Example1{pseudoJSON: cloneMap(p)}
}

func (v Example1) PseudoJSON() map[string]any {
    return cloneMap(v.pseudoJSON)
}
func NewExample1(
    field1 int,
    int_ *bool,
    field4 any,
    field5 Un1,
    field6 TestInput,
    build []int,
    build2 map[string]int,
    field9 []Example5,
    long Optional[string],
    field7 Optional[*Un1],
    field8 Optional[Example4],
) Example1 {
    input := make(map[string]any)
    input["field1"] = field1
    input["int"] = encodeNullable(int_, identity[bool])
    if encoded3, ok := encodeOptional(long, func(v string) any { return v }); ok {
        input["long!"] = encoded3
    }
    input["field4"] = field4
    input["field5"] = field5.PseudoJSON()
    input["field6"] = field6.PseudoJSON()
    input["build"] = encodeSlice(build, func(e0 int) any { return e0 })
    input["build2"] = encodeMap(build2, func(v0 int) any { return v0 })
    if encoded9, ok := encodeOptional(field7, func(v *Un1) any { return encodeNullable(v, func(v Un1) any { return v.PseudoJSON() }) }); ok {
        input["field7!"] = encoded9
    }
    if encoded10, ok := encodeOptional(field8, func(v Example4) any { return v.PseudoJSON() }); ok {
        input["field8!"] = encoded10
    }
    input["field9"] = encodeSlice(field9, func(e0 Example5) any { return e0.PseudoJSON() })
    return Example1{pseudoJSON: input}
}
func (v Example1) Field1() int {
    raw := v.pseudoJSON["field1"]
    return asInt(raw)
}


func (v Example1) Int() *bool {
    raw := v.pseudoJSON["int"]
    return nullable(raw, func(v any) bool { return asBool(v) })
}


func (v Example1) Long() (string, bool) {
    raw, ok := v.pseudoJSON["long!"]
    if !ok {
        var zero string
        return zero, false
    }
    return asString(raw), true
}


func (v Example1) Field4() any {
    raw := v.pseudoJSON["field4"]
    return raw
}


func (v Example1) Field5() Un1 {
    raw := v.pseudoJSON["field5"]
    return NewUn1FromPseudoJSON(asMap(raw))
}


func (v Example1) Field6() TestInput {
    raw := v.pseudoJSON["field6"]
    return NewTestInputFromPseudoJSON(asMap(raw))
}


func (v Example1) Build() []int {
    raw := v.pseudoJSON["build"]
    return decodeSlice(raw, func(e0 any) int { return asInt(e0) })
}


func (v Example1) Build2() map[string]int {
    raw := v.pseudoJSON["build2"]
    return decodeMap(raw, func(e0 any) int { return asInt(e0) })
}


func (v Example1) Field7() (*Un1, bool) {
    raw, ok := v.pseudoJSON["field7!"]
    if !ok {
        var zero *Un1
        return zero, false
    }
    return nullable(raw, func(v any) Un1 { return NewUn1FromPseudoJSON(asMap(v)) }), true
}


func (v Example1) Field8() (Example4, bool) {
    raw, ok := v.pseudoJSON["field8!"]
    if !ok {
        var zero Example4
        return zero, false
    }
    return NewExample4FromPseudoJSON(asMap(raw)), true
}


func (v Example1) Field9() []Example5 {
    raw := v.pseudoJSON["field9"]
    return decodeSlice(raw, func(e0 any) Example5 { return NewExample5FromPseudoJSON(asMap(e0)) })
}



type Example2 struct {
    pseudoJSON map[string]any
}

func NewExample2FromPseudoJSON(p map[string]any) Example2 {
    return Example2{pseudoJSON: cloneMap(p)}
}

func (v Example2) PseudoJSON() map[string]any {
    return cloneMap(v.pseudoJSON)
}
func NewExample2(
    field1 bool,
    field2 []string,
) Example2 {
    input := make(map[string]any)
    input["field1"] = field1
    input["field2"] = encodeSlice(field2, func(e0 string) any { return e0 })
    return Example2{pseudoJSON: input}
}
func (v Example2) Field1() bool {
    raw := v.pseudoJSON["field1"]
    return asBool(raw)
}


func (v Example2) Field2() []string {
    raw := v.pseudoJSON["field2"]
    return decodeSlice(raw, func(e0 any) string { return asString(e0) })
}



type Example3 struct {
    pseudoJSON map[string]any
}

func NewExample3FromPseudoJSON(p map[string]any) Example3 {
    return Example3{pseudoJSON: cloneMap(p)}
}

func (v Example3) PseudoJSON() map[string]any {
    return cloneMap(v.pseudoJSON)
}
func NewExample3(
    field1 bool,
    field2 [][]string,
) Example3 {
    input := make(map[string]any)
    input["field1"] = field1
    input["field2"] = encodeSlice(field2, func(e0 []string) any { return encodeSlice(e0, func(e1 string) any { return e1 }) })
    return Example3{pseudoJSON: input}
}
func (v Example3) Field1() bool {
    raw := v.pseudoJSON["field1"]
    return asBool(raw)
}


func (v Example3) Field2() [][]string {
    raw := v.pseudoJSON["field2"]
    return decodeSlice(raw, func(e0 any) []string { return decodeSlice(e0, func(e1 any) string { return asString(e1) }) })
}



type Example4 struct {
    pseudoJSON map[string]any
}

func NewExample4FromPseudoJSON(p map[string]any) Example4 {
    return Example4{pseudoJSON: cloneMap(p)}
}

func (v Example4) PseudoJSON() map[string]any {
    return cloneMap(v.pseudoJSON)
}
func NewExample4(
    field1 bool,
    field2 map[string]bool,
) Example4 {
    input := make(map[string]any)
    input["field1"] = field1
    input["field2"] = encodeMap(field2, func(v0 bool) any { return v0 })
    return Example4{pseudoJSON: input}
}
func (v Example4) Field1() bool {
    raw := v.pseudoJSON["field1"]
    return asBool(raw)
}


func (v Example4) Field2() map[string]bool {
    raw := v.pseudoJSON["field2"]
    return decodeMap(raw, func(e0 any) bool { return asBool(e0) })
}



type Example5 struct {
    pseudoJSON map[string]any
}

func NewExample5FromPseudoJSON(p map[string]any) Example5 {
    return Example5{pseudoJSON: cloneMap(p)}
}

func (v Example5) PseudoJSON() map[string]any {
    return cloneMap(v.pseudoJSON)
}
func NewExample5(
    field1 bool,
    field2 map[string]map[string]bool,
) Example5 {
    input := make(map[string]any)
    input["field1"] = field1
    input["field2"] = encodeMap(field2, func(v0 map[string]bool) any { return encodeMap(v0, func(v1 bool) any { return v1 }) })
    return Example5{pseudoJSON: input}
}
func (v Example5) Field1() bool {
    raw := v.pseudoJSON["field1"]
    return asBool(raw)
}


func (v Example5) Field2() map[string]map[string]bool {
    raw := v.pseudoJSON["field2"]
    return decodeMap(raw, func(e0 any) map[string]bool { return decodeMap(e0, func(e1 any) bool { return asBool(e1) }) })
}



type Example6 struct {
    pseudoJSON map[string]any
}

func NewExample6FromPseudoJSON(p map[string]any) Example6 {
    return Example6{pseudoJSON: cloneMap(p)}
}

func (v Example6) PseudoJSON() map[string]any {
    return cloneMap(v.pseudoJSON)
}
func NewExample6(
    field1 bool,
    field2 Example1,
    field3 *Example1,
) Example6 {
    input := make(map[string]any)
    input["field1"] = field1
    input["field2"] = field2.PseudoJSON()
    input["field3"] = encodeNullable(field3, func(v Example1) any { return v.PseudoJSON() })
    return Example6{pseudoJSON: input}
}
func (v Example6) Field1() bool {
    raw := v.pseudoJSON["field1"]
    return asBool(raw)
}


func (v Example6) Field2() Example1 {
    raw := v.pseudoJSON["field2"]
    return NewExample1FromPseudoJSON(asMap(raw))
}


func (v Example6) Field3() *Example1 {
    raw := v.pseudoJSON["field3"]
    return nullable(raw, func(v any) Example1 { return NewExample1FromPseudoJSON(asMap(v)) })
}



// A union
// 
// This is the result.
type Un1 struct {
    pseudoJSON map[string]any
}

func NewUn1FromPseudoJSON(p map[string]any) Un1 {
    return Un1{pseudoJSON: cloneMap(p)}
}

func (v Un1) PseudoJSON() map[string]any {
    return cloneMap(v.pseudoJSON)
}
func NewUn1FromFirst(payload Un1First) Un1 {
    return Un1{pseudoJSON: map[string]any{"First": payload.PseudoJSON()}}
}
func NewUn1FromSecond(payload Un1Second) Un1 {
    return Un1{pseudoJSON: map[string]any{"Second": payload.PseudoJSON()}}
}

func (v Un1) TaggedValue() TaggedValue[string, any] {
    tag := firstKey(v.pseudoJSON)
    switch tag {
    case "First":
        return TaggedValue[string, any]{Tag: "First", Value: NewUn1FirstFromPseudoJSON(asMap(v.pseudoJSON["First"]))}
    case "Second":
        return TaggedValue[string, any]{Tag: "Second", Value: NewUn1SecondFromPseudoJSON(asMap(v.pseudoJSON["Second"]))}
    default:
        value := map[string]any{}
        if raw, ok := v.pseudoJSON[tag]; ok {
            value = asMap(raw)
        }
        return TaggedValue[string, any]{Tag: "NoMatch_", Value: UntypedTaggedValue{Tag: tag, Value: value}}
    }
}

// First union entry
// 
// This is first.
type Un1First struct {
    pseudoJSON map[string]any
}

func NewUn1FirstFromPseudoJSON(p map[string]any) Un1First {
    return Un1First{pseudoJSON: cloneMap(p)}
}

func (v Un1First) PseudoJSON() map[string]any {
    return cloneMap(v.pseudoJSON)
}
func NewUn1First(
    field1 int,
    field2 bool,
) Un1First {
    input := make(map[string]any)
    input["field1"] = field1
    input["field2"] = field2
    return Un1First{pseudoJSON: input}
}
func (v Un1First) Field1() int {
    raw := v.pseudoJSON["field1"]
    return asInt(raw)
}


func (v Un1First) Field2() bool {
    raw := v.pseudoJSON["field2"]
    return asBool(raw)
}



// Second union entry
// 
// This is second.
type Un1Second struct {
    pseudoJSON map[string]any
}

func NewUn1SecondFromPseudoJSON(p map[string]any) Un1Second {
    return Un1Second{pseudoJSON: cloneMap(p)}
}

func (v Un1Second) PseudoJSON() map[string]any {
    return cloneMap(v.pseudoJSON)
}
func NewUn1Second(
    field1 string,
    field2 bool,
) Un1Second {
    input := make(map[string]any)
    input["field1"] = field1
    input["field2"] = field2
    return Un1Second{pseudoJSON: input}
}
func (v Un1Second) Field1() string {
    raw := v.pseudoJSON["field1"]
    return asString(raw)
}


func (v Un1Second) Field2() bool {
    raw := v.pseudoJSON["field2"]
    return asBool(raw)
}



type AnotherInput struct {
    pseudoJSON map[string]any
}

func NewAnotherInputFromPseudoJSON(p map[string]any) AnotherInput {
    return AnotherInput{pseudoJSON: cloneMap(p)}
}

func (v AnotherInput) PseudoJSON() map[string]any {
    return cloneMap(v.pseudoJSON)
}
func NewAnotherInput() AnotherInput {
    return AnotherInput{pseudoJSON: map[string]any{"fn.another": map[string]any{}}}
}

func (v AnotherInput) payload() map[string]any {
    return asMap(v.pseudoJSON["fn.another"])
}
type AnotherOutput struct {
    pseudoJSON map[string]any
}

func NewAnotherOutputFromPseudoJSON(p map[string]any) AnotherOutput {
    return AnotherOutput{pseudoJSON: cloneMap(p)}
}

func (v AnotherOutput) PseudoJSON() map[string]any {
    return cloneMap(v.pseudoJSON)
}
func NewAnotherOutputFromOk(payload AnotherOutputOk) AnotherOutput {
    return AnotherOutput{pseudoJSON: map[string]any{"Ok_": payload.PseudoJSON()}}
}
func NewAnotherOutputFromExtraError1(payload AnotherOutputExtraError1) AnotherOutput {
    return AnotherOutput{pseudoJSON: map[string]any{"ExtraError1": payload.PseudoJSON()}}
}
func NewAnotherOutputFromExtraError2(payload AnotherOutputExtraError2) AnotherOutput {
    return AnotherOutput{pseudoJSON: map[string]any{"ExtraError2": payload.PseudoJSON()}}
}

func (v AnotherOutput) TaggedValue() TaggedValue[string, any] {
    tag := firstKey(v.pseudoJSON)
    switch tag {
    case "Ok_":
        return TaggedValue[string, any]{Tag: "Ok_", Value: NewAnotherOutputOkFromPseudoJSON(asMap(v.pseudoJSON["Ok_"]))}
    case "ExtraError1":
        return TaggedValue[string, any]{Tag: "ExtraError1", Value: NewAnotherOutputExtraError1FromPseudoJSON(asMap(v.pseudoJSON["ExtraError1"]))}
    case "ExtraError2":
        return TaggedValue[string, any]{Tag: "ExtraError2", Value: NewAnotherOutputExtraError2FromPseudoJSON(asMap(v.pseudoJSON["ExtraError2"]))}
    default:
        value := map[string]any{}
        if raw, ok := v.pseudoJSON[tag]; ok {
            value = asMap(raw)
        }
        return TaggedValue[string, any]{Tag: "NoMatch_", Value: UntypedTaggedValue{Tag: tag, Value: value}}
    }
}

type AnotherOutputOk struct {
    pseudoJSON map[string]any
}

func NewAnotherOutputOkFromPseudoJSON(p map[string]any) AnotherOutputOk {
    return AnotherOutputOk{pseudoJSON: cloneMap(p)}
}

func (v AnotherOutputOk) PseudoJSON() map[string]any {
    return cloneMap(v.pseudoJSON)
}
func NewAnotherOutputOk(
    field1 int,
) AnotherOutputOk {
    input := make(map[string]any)
    input["field1"] = field1
    return AnotherOutputOk{pseudoJSON: input}
}
func (v AnotherOutputOk) Field1() int {
    raw := v.pseudoJSON["field1"]
    return asInt(raw)
}



type AnotherOutputExtraError1 struct {
    pseudoJSON map[string]any
}

func NewAnotherOutputExtraError1FromPseudoJSON(p map[string]any) AnotherOutputExtraError1 {
    return AnotherOutputExtraError1{pseudoJSON: cloneMap(p)}
}

func (v AnotherOutputExtraError1) PseudoJSON() map[string]any {
    return cloneMap(v.pseudoJSON)
}
func NewAnotherOutputExtraError1(
    field1 int,
) AnotherOutputExtraError1 {
    input := make(map[string]any)
    input["field1"] = field1
    return AnotherOutputExtraError1{pseudoJSON: input}
}
func (v AnotherOutputExtraError1) Field1() int {
    raw := v.pseudoJSON["field1"]
    return asInt(raw)
}



type AnotherOutputExtraError2 struct {
    pseudoJSON map[string]any
}

func NewAnotherOutputExtraError2FromPseudoJSON(p map[string]any) AnotherOutputExtraError2 {
    return AnotherOutputExtraError2{pseudoJSON: cloneMap(p)}
}

func (v AnotherOutputExtraError2) PseudoJSON() map[string]any {
    return cloneMap(v.pseudoJSON)
}
func NewAnotherOutputExtraError2(
    field1 string,
) AnotherOutputExtraError2 {
    input := make(map[string]any)
    input["field1"] = field1
    return AnotherOutputExtraError2{pseudoJSON: input}
}
func (v AnotherOutputExtraError2) Field1() string {
    raw := v.pseudoJSON["field1"]
    return asString(raw)
}



type AnotherSelect struct {
    pseudoJSON map[string]any
}

func NewAnotherSelect() *AnotherSelect {
    return &AnotherSelect{pseudoJSON: map[string]any{}}
}

func (s *AnotherSelect) PseudoJSON() map[string]any {
    return cloneMap(s.pseudoJSON)
}
func (s *AnotherSelect) OkField1() *AnotherSelect {
    result := ensureStringMap(s.pseudoJSON["->"])
    fields := appendUnique(result["Ok_"], "field1")
    result["Ok_"] = fields
    s.pseudoJSON["->"] = result
    return s
}

// A function
// 
// This is the result.
type TestInput struct {
    pseudoJSON map[string]any
}

func NewTestInputFromPseudoJSON(p map[string]any) TestInput {
    return TestInput{pseudoJSON: cloneMap(p)}
}

func (v TestInput) PseudoJSON() map[string]any {
    return cloneMap(v.pseudoJSON)
}
func NewTestInput(
    field1 int,
    field2 bool,
) TestInput {
    payload := make(map[string]any)
    payload["field1"] = field1
    payload["field2"] = field2
    return TestInput{pseudoJSON: map[string]any{"fn.test": payload}}
}

func (v TestInput) payload() map[string]any {
    return asMap(v.pseudoJSON["fn.test"])
}
func (v TestInput) Field1() int {
    payload := v.payload()
    raw := payload["field1"]
    return asInt(raw)
}
func (v TestInput) Field2() bool {
    payload := v.payload()
    raw := payload["field2"]
    return asBool(raw)
}
// A function
// 
// This is the result.
type TestOutput struct {
    pseudoJSON map[string]any
}

func NewTestOutputFromPseudoJSON(p map[string]any) TestOutput {
    return TestOutput{pseudoJSON: cloneMap(p)}
}

func (v TestOutput) PseudoJSON() map[string]any {
    return cloneMap(v.pseudoJSON)
}
func NewTestOutputFromOk(payload TestOutputOk) TestOutput {
    return TestOutput{pseudoJSON: map[string]any{"Ok_": payload.PseudoJSON()}}
}
func NewTestOutputFromErr(payload TestOutputErr) TestOutput {
    return TestOutput{pseudoJSON: map[string]any{"Err": payload.PseudoJSON()}}
}
func NewTestOutputFromExtraError1(payload TestOutputExtraError1) TestOutput {
    return TestOutput{pseudoJSON: map[string]any{"ExtraError1": payload.PseudoJSON()}}
}
func NewTestOutputFromExtraError2(payload TestOutputExtraError2) TestOutput {
    return TestOutput{pseudoJSON: map[string]any{"ExtraError2": payload.PseudoJSON()}}
}

func (v TestOutput) TaggedValue() TaggedValue[string, any] {
    tag := firstKey(v.pseudoJSON)
    switch tag {
    case "Ok_":
        return TaggedValue[string, any]{Tag: "Ok_", Value: NewTestOutputOkFromPseudoJSON(asMap(v.pseudoJSON["Ok_"]))}
    case "Err":
        return TaggedValue[string, any]{Tag: "Err", Value: NewTestOutputErrFromPseudoJSON(asMap(v.pseudoJSON["Err"]))}
    case "ExtraError1":
        return TaggedValue[string, any]{Tag: "ExtraError1", Value: NewTestOutputExtraError1FromPseudoJSON(asMap(v.pseudoJSON["ExtraError1"]))}
    case "ExtraError2":
        return TaggedValue[string, any]{Tag: "ExtraError2", Value: NewTestOutputExtraError2FromPseudoJSON(asMap(v.pseudoJSON["ExtraError2"]))}
    default:
        value := map[string]any{}
        if raw, ok := v.pseudoJSON[tag]; ok {
            value = asMap(raw)
        }
        return TaggedValue[string, any]{Tag: "NoMatch_", Value: UntypedTaggedValue{Tag: tag, Value: value}}
    }
}

type TestOutputOk struct {
    pseudoJSON map[string]any
}

func NewTestOutputOkFromPseudoJSON(p map[string]any) TestOutputOk {
    return TestOutputOk{pseudoJSON: cloneMap(p)}
}

func (v TestOutputOk) PseudoJSON() map[string]any {
    return cloneMap(v.pseudoJSON)
}
func NewTestOutputOk(
    field1 int,
    field2 bool,
) TestOutputOk {
    input := make(map[string]any)
    input["field1"] = field1
    input["field2"] = field2
    return TestOutputOk{pseudoJSON: input}
}
func (v TestOutputOk) Field1() int {
    raw := v.pseudoJSON["field1"]
    return asInt(raw)
}


func (v TestOutputOk) Field2() bool {
    raw := v.pseudoJSON["field2"]
    return asBool(raw)
}



type TestOutputErr struct {
    pseudoJSON map[string]any
}

func NewTestOutputErrFromPseudoJSON(p map[string]any) TestOutputErr {
    return TestOutputErr{pseudoJSON: cloneMap(p)}
}

func (v TestOutputErr) PseudoJSON() map[string]any {
    return cloneMap(v.pseudoJSON)
}
func NewTestOutputErr(
    error_ string,
) TestOutputErr {
    input := make(map[string]any)
    input["error"] = error_
    return TestOutputErr{pseudoJSON: input}
}
func (v TestOutputErr) Error() string {
    raw := v.pseudoJSON["error"]
    return asString(raw)
}



type TestOutputExtraError1 struct {
    pseudoJSON map[string]any
}

func NewTestOutputExtraError1FromPseudoJSON(p map[string]any) TestOutputExtraError1 {
    return TestOutputExtraError1{pseudoJSON: cloneMap(p)}
}

func (v TestOutputExtraError1) PseudoJSON() map[string]any {
    return cloneMap(v.pseudoJSON)
}
func NewTestOutputExtraError1(
    field1 int,
) TestOutputExtraError1 {
    input := make(map[string]any)
    input["field1"] = field1
    return TestOutputExtraError1{pseudoJSON: input}
}
func (v TestOutputExtraError1) Field1() int {
    raw := v.pseudoJSON["field1"]
    return asInt(raw)
}



type TestOutputExtraError2 struct {
    pseudoJSON map[string]any
}

func NewTestOutputExtraError2FromPseudoJSON(p map[string]any) TestOutputExtraError2 {
    return TestOutputExtraError2{pseudoJSON: cloneMap(p)}
}

func (v TestOutputExtraError2) PseudoJSON() map[string]any {
    return cloneMap(v.pseudoJSON)
}
func NewTestOutputExtraError2(
    field1 string,
) TestOutputExtraError2 {
    input := make(map[string]any)
    input["field1"] = field1
    return TestOutputExtraError2{pseudoJSON: input}
}
func (v TestOutputExtraError2) Field1() string {
    raw := v.pseudoJSON["field1"]
    return asString(raw)
}



type TestSelect struct {
    pseudoJSON map[string]any
}

func NewTestSelect() *TestSelect {
    return &TestSelect{pseudoJSON: map[string]any{}}
}

func (s *TestSelect) PseudoJSON() map[string]any {
    return cloneMap(s.pseudoJSON)
}
func (s *TestSelect) OkField1() *TestSelect {
    result := ensureStringMap(s.pseudoJSON["->"])
    fields := appendUnique(result["Ok_"], "field1")
    result["Ok_"] = fields
    s.pseudoJSON["->"] = result
    return s
}
func (s *TestSelect) OkField2() *TestSelect {
    result := ensureStringMap(s.pseudoJSON["->"])
    fields := appendUnique(result["Ok_"], "field2")
    result["Ok_"] = fields
    s.pseudoJSON["->"] = result
    return s
}

type Select struct {
    pseudoJSON map[string]any
}

func NewSelect() *Select {
    return &Select{pseudoJSON: map[string]any{}}
}

func (s *Select) PseudoJSON() map[string]any {
    return cloneMap(s.pseudoJSON)
}
func SelectForAnother(selectValue *AnotherSelect) *Select {
    if selectValue == nil {
        return &Select{pseudoJSON: map[string]any{}}
    }
    return &Select{pseudoJSON: cloneMap(selectValue.pseudoJSON)}
}
func SelectForTest(selectValue *TestSelect) *Select {
    if selectValue == nil {
        return &Select{pseudoJSON: map[string]any{}}
    }
    return &Select{pseudoJSON: cloneMap(selectValue.pseudoJSON)}
}

type TypedClient struct {
    client *telepact.Client
}

func NewTypedClient(client *telepact.Client) *TypedClient {
    return &TypedClient{client: client}
}
func (c *TypedClient) Another(headers map[string]any, input AnotherInput) (telepact.TypedMessage[AnotherOutput], error) {
    if c == nil || c.client == nil {
        return telepact.TypedMessage[AnotherOutput]{}, errors.New("telepact: typed client not configured")
    }

    request := telepact.NewMessage(headers, input.PseudoJSON())
    response, err := c.client.Request(request)
    if err != nil {
        return telepact.TypedMessage[AnotherOutput]{}, err
    }

    return telepact.NewTypedMessage(response.Headers, NewAnotherOutputFromPseudoJSON(response.Body)), nil
}
func (c *TypedClient) Test(headers map[string]any, input TestInput) (telepact.TypedMessage[TestOutput], error) {
    if c == nil || c.client == nil {
        return telepact.TypedMessage[TestOutput]{}, errors.New("telepact: typed client not configured")
    }

    request := telepact.NewMessage(headers, input.PseudoJSON())
    response, err := c.client.Request(request)
    if err != nil {
        return telepact.TypedMessage[TestOutput]{}, err
    }

    return telepact.NewTypedMessage(response.Headers, NewTestOutputFromPseudoJSON(response.Body)), nil
}
func (c *TypedClient) Invoke(target string, headers map[string]any, payload map[string]any) (map[string]any, map[string]any, bool, error) {
    if c == nil || c.client == nil {
        return nil, nil, false, errors.New("telepact: typed client not configured")
    }

    switch target {
    case "fn.another":
        body := map[string]any{target: payload}
        result, err := c.Another(headers, NewAnotherInputFromPseudoJSON(body))
        if err != nil {
            return nil, nil, true, err
        }
        return result.Headers, result.Body.PseudoJSON(), true, nil
    case "fn.test":
        body := map[string]any{target: payload}
        result, err := c.Test(headers, NewTestInputFromPseudoJSON(body))
        if err != nil {
            return nil, nil, true, err
        }
        return result.Headers, result.Body.PseudoJSON(), true, nil
    default:
        return nil, nil, false, nil
    }
}

type TypedServer interface {
    Another(headers map[string]any, input AnotherInput) (telepact.TypedMessage[AnotherOutput], error)
    Test(headers map[string]any, input TestInput) (telepact.TypedMessage[TestOutput], error)
}

type TypedServerHandler struct {
    Impl TypedServer
}

func NewTypedServerHandler(impl TypedServer) *TypedServerHandler {
    return &TypedServerHandler{Impl: impl}
}

func (h *TypedServerHandler) Handler(message telepact.Message) (telepact.Message, error) {
    if h == nil || h.Impl == nil {
        return telepact.Message{}, errors.New("telepact: typed server not configured")
    }

    target, err := message.BodyTarget()
    if err != nil {
        return telepact.Message{}, err
    }

    switch target {
    case "fn.another":
        result, ierr := h.Impl.Another(message.Headers, NewAnotherInputFromPseudoJSON(message.Body))
        if ierr != nil {
            return telepact.Message{}, ierr
        }
        return telepact.NewMessage(result.Headers, result.Body.PseudoJSON()), nil
    case "fn.test":
        result, ierr := h.Impl.Test(message.Headers, NewTestInputFromPseudoJSON(message.Body))
        if ierr != nil {
            return telepact.Message{}, ierr
        }
        return telepact.NewMessage(result.Headers, result.Body.PseudoJSON()), nil
    default:
        return telepact.Message{}, fmt.Errorf("telepact: unknown function %s", target)
    }
}